const VERS_NUM="ver 1.0.0 nov-01-2021";let the_exports;if(void 0===TYPE_CZECH_current_test_number)var TYPE_CZECH_current_test_number="no test number assigned yet";!function(e){e.TypeCzech=function(){return arguments.length>0?e.type_czech=t(...arguments):void 0!==e.TYPE_CZECH_COMMANDS&&e.TYPE_CZECH_COMMANDS.length>0?e.type_czech=t(e.TYPE_CZECH_COMMANDS):e.type_czech={linkUp:e=>e,isActive:e=>!1},e.type_czech;function t(...e){let t,n=!1,r=!1;const i={},o=new WeakSet,s="PRE-FUNC:",c="PRE-FUNC:",a="POST-FUNC:",l="POST-FUNC:",f="PRE-CLASS:",u="POST-CLASS:",y="PRE-OBJ:",p="PRE-OBJ:",h="POST-OBJ:",E="POST-OBJ:",$="() ";let d=!1,_=!1,g=!1,b=!1,m=!1,T=!1,k=!1;const O=100,C=50,S=O+C+10,R="<<<<<<~~~>>>>>>",N="arguments",P=`check_typeVariadic(${N}, expected_types)`,w=`check_emptyVariadic(${N}, expected_types)`,A=`check_interface(${N}, expected_types)`,v=`check_mutatedSnapshot(${N}, expected_types)`,j=`check_type(${N}, expected_types)`,M=`check_typeExtra(${N}, expected_types)`,x=`check_typeEither(${N}, expected_types)`,z=`check_empty(${N}, expected_emptys)`,Y=`check_emptyExtra(${N}, expected_emptys)`,I=`check_emptyEither(${N}, expected_emptys)`,U="TypeCzech.assert_check()",L="background: #ee0; color: #00F",V="background: #ee0; color: #F00",F="background: #cc0; color: #080",D="''",X="\n\t\t",G=/([^(]*\()([^)]*)/,K=30,B="/(?:)/",J="EMPTY-OK",H="EMPTY-ERROR",W="EMPTY-IGNORE",Z={OK:J,ER:H,IG:W},Q="TYPE-EXTRAS",q="TYPE-VERIFY",ee="EMPTY-EXTRAS",te="EMPTY-VERIFY",ne=["Array","BigInt","Boolean","Date","Function","Number","Object","RegExp","String","Symbol"],re={array:"Array",bigint:"BigInt",boolean:"Boolean",date:"Date",function:"Function",number:"Number",object:"Object",regexp:"RegExp",string:"String",symbol:"Symbol"},ie=["array","bigint","boolean","date","function","number","object","regexp","string","symbol"],oe=new Set(ie),se={a:"array",i:"bigint",b:"boolean",d:"date",f:"function",n:"number",o:"object",r:"regexp",s:"string",y:"symbol"},ce="undefined",ae="null",le="NaN",fe="Infinity",ue="TypeCzech-undefined-Stringify-Value:undefined",ye=`"${ue}"`,pe="TypeCzech-null-Stringify-Value:null",he=`"${pe}"`,Ee="TypeCzech-NaN-Stringify-Value:NaN",$e=`"${Ee}"`,de="TypeCzech-Infinity-Stringify-Value:Infinity",_e=`"${de}"`,ge="TypeCzech-init",be={backBlinkUp:e=>{document.body.style.background=e,setTimeout(()=>{document.body.style.background="white"},100)},onStart:()=>be.backBlink("green"),onCheck:()=>be.backBlink("blue"),onError:()=>be.backBlink("red")};function me(e,t){const n=Se(e),r=n.substring(1,n.length-1);console.log(`%c ${r}`,t)}function Te(e){return e.replace(/"/g,"'")}function ke(e){const t=ze(e);return"array"===t||"object"===t}function Oe(e){let t;if(ke(e))t=Le(e);else if(void 0===e)t=ce;else if("bigint"==typeof e)t=`${e}n`;else if("string"==typeof e)if(e===he)t=ae;else if(e===ye)t=ce;else if(e===$e)t=le;else if(e===_e)t=fe;else{let n=e.replace(/"/g,'"');if(n.startsWith('"{')&&n.endsWith('}"')){const e=n.length-1;t=n.substring(1,e)}else 0===(n=(n=n.replace(/"$/g,"")).replace(/^"/g,"")).length&&(n="''"),t=n}else if("symbol"==typeof e)t=(t=(t=e.toString()).replace(/\(/g,"('")).replace(/\)/g,"')");else{const n=Se(e);if("object"==typeof e){t=Te(n)}else t=n}return t}function Ce(e,t){let n;if("bigint"==typeof t)n=`${t}n`;else if(null===t)n=pe;else if(void 0===t)n=ue;else if(Number.isNaN(t))n=Ee;else if("number"!=typeof t||Number.isFinite(t))if("function"==typeof t){n=`${String(t).replace(/\s+/g," ").substring(0,K)} ***`}else if(t&&t.constructor===RegExp){n=`${String(t).substring(0,K)} +++`}else n="string"==typeof t?t:"symbol"==typeof t?Oe(t):t;else n=de;return n}function Se(e){return Oe(JSON.stringify(e,Ce))}function Re(e){let t="";const n=e.toString();return n.startsWith("class ")&&n.includes(" constructor(")&&(t=e.name),t}function Ne(e){let t=!1;if(null!=e){if("function"===typeof Object.getPrototypeOf(e)){if("object"===typeof e.prototype){Re(e)&&(t=!0)}}}return t}function Pe(e){let t="";return e.toString().startsWith("function ")&&(t=e.name),t}function we(e){let t=!1;return"string"==typeof e&&ne.includes(e)&&(t=!0),t}function Ae(e){let t=!1;if(null!=e){if("object"===typeof Object.getPrototypeOf(e)){const n=e.constructor,r=Re(n);if(r)t=r;else{t=Pe(n)}}}return we(t)&&(t=t.toLowerCase()),t}function ve(e){let t=!1;return"string"==typeof e&&ie.includes(e)&&(t=!0),t}function je(e){let t=!1;if(null!=e){const n=[];const r=Object.getPrototypeOf(e).constructor.name;"object"!==r&&ne.includes(r)?t=[r]:(!function e(t){const r=Object.getPrototypeOf(t);if(null!==r){const t=r.constructor.name;n.push(t),e(r)}}(e),t=n)}else t=null===e?[ae]:[ce];return t}function Me(e){const t=je(e);let n=!1;return t&&we(n=t.shift())&&(n=n.toLowerCase()),n||(n=void 0===e?ce:ae),n}function xe(e,t){const n=je(e);let r=!1;return n&&(ve(t)&&(t=re[t]),r=n.includes(t)),r}function ze(e){let t="";const n=Me(e);return t=n||(null===e?"null":e instanceof Date?"date":e instanceof RegExp?"regexp":Array.isArray(e)?"array":typeof e)}function Ye(e){let t=!1;return oe.has(e)?t=!0:se[e]&&(t=!0),t}function Ie(e){return se[e]&&(e=se[e]),e}function Ue(e){return Z[e]?Z[e]:e}function Le(e){let t;const n=[];if(Array.isArray(e))e.forEach(e=>{const t=Oe(e);"string"===ze(e)?"''"===t?n.push('""'):n.push(`"${t}"`):n.push(t)}),t=`[${n.join()}]`;else{for(const[t,r]of Object.entries(e)){const e=Oe(r);let i;i="string"===ze(r)?"''"===e?`${t}:""`:`${t}:"${e}"`:`${t}:${e}`,n.push(i)}t=`{${n.join()}}`}return t}function Ve(e,t){if(T&&t){const n=`${t} - ${e}`;return k&&me(n,V),n}return e}function Fe(e){let t="";if(!ve(e)&&"string"==typeof e){const n=e.toLowerCase();if(re[n]){t=Ve(`The type '${e}' is not a typeof() type, but it looks just like '${n}'`,"TE@205")}}return t}function De(e){let t;if(Object.keys(e).length>0){const[n,r]=Object.entries(e)[0];if(!(t=Fe(r))){t=Ve(` The key '${n}', which has a type of '${Oe(r)}', is missing in the checked object`,"TE@216")}}else t="";return t}function Xe(e){let t;if(e instanceof Date)t="Invalid Date"==e;else if(e instanceof RegExp){t=e.toString()===B}else if(Number.isNaN(e))t=!0;else if("number"!=typeof e||Number.isFinite(e))if(null==e)t=!0;else{const n=0===e.length,r="object"==typeof e&&0===Object.keys(e).length;t=n||r}else t=!0;return t}const Ge=e=>"array"===e||("object"===e||("string"===e||("regexp"===e||("date"===e||"number"===e))));function Ke(e,t){let n;return 1===e.length?[n]=e:n=e[t],n}function Be(e){let t;let n=!1,r=!0;return null==e||void 0===e.length||"string"==typeof e?t=e:0===e.length?(Array.isArray(e)||(n=!0),t=[]):1===e.length?t=Array.isArray(e)?e:e[0]:(t=Array.from(e),r=!1),[t,n,r]}function Je(e,t,n){return[e,t,Oe(n)]}function He(e){const n=arguments.length;if(n>1){throw Ve(`TypeCzech._ParametersCheck() - Internal - needs 0 or 1 parameters, not ${n}`,"ME@407")}let i=()=>"",T=()=>"",k=0,O=0,C=!1;function S(){return`${k} : ${O}`}function R(e,t,n,r){const[i,o,s]=n;let c,a=function(e){const t=[];return e.forEach(e=>{const n=Me(e);if(n)t.push(`'${n}'`);else{const n=Se(e);t.push(n)}}),t}(e);if(a.length>1)a=`[${a}]`,c=Oe(e);else{const t=Oe(e);c=t.substring(1,t.length-1)}let l=t+o;l+=X+i;let f=" EMPTY ASSERTION";return i===j||i===P||i===M||i===x?f="   EXPECTED TYPE":i===v?f="":i===U&&(f="  EXPECTED"),l+=`${X}    ACTUAL TYPES ${a}`,l+=`${X}    ACTUAL VALUE ${c}`,f&&(l+=`${X}${f} ${s}`),l+=`${X}CALLING FUNCTION ${r}`,l+=X}function N(e,t,n,r,i){if(k+=1,m&&me([k],L),e){let o;if(O+=1,T(S()),o=i===U?` ${t}`:` ${t}() ${n} `,o="string"==typeof e?e:R(r,o,e,i),d)throw new Error(o);g&&console.log(o)}}function w(e){const t=e.toString().match(G),n=`${t[0]})`.replace(/^function /,"");if(t[2].split(", ").includes("arguments")){me(`Parameter 'arguments' shadows arguments object : ${t[0]})`,L)}return n}function A(e,t,n){const r=w(n);N(n.apply(null,t),n.name,e,t,r)}function z(e,t,n,r){const i=w(r);N(r.apply(t,n),r.name,e,n,i)}function Y(e,t,n){if("function"!=typeof e&&"object"!=typeof e){throw Ve(`${t}, is a not a function or an object that has a value of '${Oe(e)}'`,n)}}function I(e,t){const n=function(e){let t;if("object"==typeof e){const n=e=>`${e}()`,r=(e,t)=>`${e}, ${t}`;t=`{ ${Object.keys(e).map(n).reduce(r)} }`}else t=`${e.name}()`;return t}(t);if(void 0===e){throw Ve(`The function to be checked by ${n} is 'undefined', maybe namespace issue`,"EX@102")}if(e===t){throw Ve(`_ParametersCheck you cannot use ${e.name}() to test`+`${t.name}(), they must be different functions`,"EX@103")}}function D(e,t,n){const r=e.name;return new Proxy(e,{apply(e,o,f){if(i(S()),C&&t)if(void 0===o){A(`${r}${$}${s}`,f,t)}else{z(`${r}${$}${c}`,o,f,t)}const u=e.apply(o,f);if(C&&n)if(void 0===o){A(`${r}${$}${a}`,[u],n)}else{z(`${r}${$}${l}`,o,[u],n)}return u}})}function K(e,t,n,r){const i=new Set;n&&Object.keys(n).forEach(e=>i.add(e)),r&&Object.keys(r).forEach(e=>i.add(e));let o=!1;return Object.isFrozen(t)&&(o=!0,t=Object.assign({},t)),i.forEach(i=>{if(i!==e){let e=!1;n&&(e=n[i]||!1);let o=!1;r&&(o=r[i]||!1),t[i]&&(t[i]=D(t[i],e,o))}}),o&&Object.freeze(t),t}function B(e,t){let n;return n="function"==typeof e?e:void 0!==e&&e[t]}const J=r?function(e,t,n){const r=arguments.length;if(2!==r&&3!==r)throw Ve(`TypeCzech.linkUp() needs 2 or 3 parameters, not ${r}`,"EX@106");let s;if(function(e,t,n){if(o.has(e))throw Ve(`${e.name}() is already proxied with ${e.name}`,"EX@104");if("function"!=typeof e)throw Ve(`The first parameter to TypeCzech.linkUp(), target_proxy is not a function, but is instead ${Oe(e)}`,"EX@105");if(t)for(const n in t){const r=t[n];I(e,r),Y(r,"TypeCzech.linkUp() 2nd parameter, PRE-CHECK()","EX@101")}if(n)for(const t in n){const r=n[t];I(e,r),Y(r,"TypeCzech.linkUp() 3rd parameter, POST-CHECK()","EX@115")}}(e,t,n),Ne(e))s=function(e,t,n){const r=e.name,o=B(t,r),s=B(n,r);return new Proxy(e,{apply(){},construct(e,c,a){let l;return i(S()),C&&o&&A(`${r}${$}${f}`,c,o),l=Reflect.construct(e,c,a),l=K(r,l,t,n),C&&s&&z(`${r}${$}${u}`,l,[l],s),l}})}(e,t,n);else{const r=ze(t),o=ze(n);s="object"===r||"object"===o?function(e,t,n){const r=e.name,o=B(t,r),s=B(n,r);return new Proxy(e,{apply(e,c,a){i(S()),C&&o&&A(`${r}${$}${y}`,a,o);let l=e.apply(c,a);return l=K(r,l,t,n),C&&s&&A(`${r}${$}${p}`,[l],n[r]),l},construct(e,c){i(S()),C&&o&&A(`${r}${$}${h}`,c,o);let a=new e(...c);return a=K(r,a,t,n),C&&s&&z(`${r}${$}${E}`,a,[a],s),a}})}(e,t,n):D(e,t,n)}return o.add(s),s}:(e,t,n)=>e;return r&&(e&&"object"!==ze(e)&&me(["_ParametersCheck - arg_check_events is not an Object with onStart(), onCheck(), onError() ",e],V),"undefined"!=typeof window&&me([ge,VERS_NUM,d?"THROW-EXCEPTIONS":"",g?"LOG-ERRORS":"",_?"LOG-ERRORS":"",b?"UNDEF-OK":"",m?"CONSOLE-COUNT":"",e],F),void 0!==e.onStart&&e.onStart("Start"),void 0!==e.onCheck&&(i=e.onCheck),void 0!==e.onError&&(T=e.onError),C=!0),{confirmParameters:J,enableChecks_:function(){C=!0,r=!0,k=0,O=0},countTally_:function(){return k},disableChecks_:function(){C=!1,r=!1},countFails_:function(){return O},assert_check_:function(e,n,r,i){if(t.p_call_traps){if(!Array.isArray(e)){const t=`\n  Assert Message: ${e=Oe(e)} `;i=void 0===i?"":Oe(i),e=[U,t,i]}N(e,`Assert Location: ${n=Oe(n)} : `,"",[r],U)}},p_call_traps:C}}const We={};function Ze(e,t){t||(t={}),"function"==typeof t&&(t={cmp:t});var n,r="boolean"==typeof t.cycles&&t.cycles,i=t.cmp&&(n=t.cmp,function(e){return function(t,r){var i={key:t,value:e[t]},o={key:r,value:e[r]};return n(i,o)}}),o=[];return function e(t){if(t&&t.toJSON&&"function"==typeof t.toJSON&&(t=t.toJSON()),Number.isNaN(t))return"NaN";if("number"==typeof t&&!Number.isFinite(t))return"Infinity";if(void 0===t)return"undefined";if("bigint"==typeof t)return JSON.stringify(t+"n");if("symbol"==typeof t)return t.toString();if("function"==typeof t){const e=String(t).substring(0,K);return replaced_value=`${e} ***`,replaced_value}if(t&&t.constructor===RegExp){const e=String(t).substring(0,K);return replaced_value=`${e} +++`,replaced_value}if("number"==typeof t)return isFinite(t)?""+t:"null";if("object"!=typeof t)return JSON.stringify(t);var n,s;if(Array.isArray(t)){for(s="[",n=0;n<t.length;n++)n&&(s+=","),s+=e(t[n])||"null";return s+"]"}if(null===t)return"null";if(-1!==o.indexOf(t)){if(r)return JSON.stringify("__cycle__");throw new TypeError("Converting circular structure to JSON")}var c=o.push(t)-1,a=Object.keys(t).sort(i&&i(t));for(s="",n=0;n<a.length;n++){var l=a[n],f=e(t[l]);f&&(s&&(s+=","),s+=JSON.stringify(l)+":"+f)}return o.splice(c,1),"{"+s+"}"}(e)}function Qe(e,t){const n=Object.entries(e),[r,i]=n[0];return Ve(`Element '${r}' is supposed to be a '${i}', but is missing : ${Oe(t)}`,"TE@221")}function qe(e,t,n){let r="";const i=ze(e),o=ze(t);if(void 0===t)r="";else if(i!==o){if(i===t);else if(n!==Q||"array"!==o){const n=Se(e);let s;r=Ve(`Parameter is meant to be '${s="string"===ze(t)?t:o}' but is`+` of the wrong type of '${i}':${n}`,"TE@207")}}else"array"===o?r=nt(e,t,n):"object"===o&&(r=it(e,t,n));return r}We.decycle=function(e,t){"use strict";var n=new WeakMap;return function e(r,i){var o,s;return void 0!==t&&(r=t(r)),"object"!=typeof r||null===r||r instanceof Boolean||r instanceof Date||r instanceof Number||r instanceof RegExp||r instanceof String?r:void 0!==(o=n.get(r))?{$ref:o}:(n.set(r,i),Array.isArray(r)?(s=[],r.forEach(function(t,n){s[n]=e(t,i+"["+n+"]")})):(s={},Object.keys(r).forEach(function(t){s[t]=e(r[t],i+"["+JSON.stringify(t)+"]")})),s)}(e,"$")};const et=(e,t,n)=>{let r="";const i=Ie(t);return Array.isArray(e)||(e=[e]),e.forEach((e,t)=>{if(""===r){const o=ze(e);if(ke(i))r=st(e,i,n);else if(i!==o)if(b&&"null"===o);else if(b&&"undefined"===o);else{let n=Fe(i);if(!n){const r=Oe(e);n=Ve(`ELEMENT '${t}' is asserted to be a '${i}',`+` but is fallaciously a '${o}' : ${r}`,"TE@215")}r=n}}}),r},tt=(e,t,n)=>{let r="";if("null"===e){r=Ve(` ELEMENT '${t}' type is invalid 'null'`,"TE@204")}else if("undefined"===e){r=Ve(` ELEMENT '${t}' type is invalid 'undefined'`,"TE@229")}else if("string"!=typeof e){r=Ve(` ELEMENT '${t}' type is invalid as it is not a string but instead ${Oe(e)}`,"TE@232")}if(!r&&!(r=Fe(e))){r=Ve(` ELEMENT '${t}' is assumed to be a '${e}',`+` but is mistakenly a '${n}'`,"TE@214")}return r};function nt(e,t,n){let r="";if(1===t.length&&e.length>1){const i=t[0];r=et(e,i,n)}else{const i=Array.from(t),o=i.length;e.forEach((e,t)=>{if(""===r){const o=ze(e),s=Ke(i,t);if(ke(s))r=qe(e,s,n);else{const e=Ie(Ke(i,t));e!==o&&(n===Q&&void 0===e||b&&"null"===o||b&&"undefined"===o||(r=tt(e,t,o)))}delete i[t]}}),r||1!==o&&e.length<o&&(r=Qe(i,e))}return r}const rt=(e,t,n)=>{let r="";const i=Ie(e[t]);if(Ye(i)){const e=ze(n);if(i!==e)if(b&&"null"===e);else if(b&&"undefined"===e);else if(void 0===n){r=Ve(`Key '${t}' was given to be a '${i}' but was instead 'undefined'`,"TE@211")}else if("null"===e){r=Ve(`Key '${t}' was determined to be a '${i}' but was instead 'null'`,"TE@212")}else{r=Ve(`Property '${t}' is indicated to be a '${i}',`+` but is inaccurately a '${e}' : ${Oe(n)}`,"TE@213")}}else if(!(r=Fe(i))){r=Ve(`The type '${Se(i)}' is not a real type`,"TE@210")}return r};function it(e,t,n){let r="";const i={...t};return Object.entries(e).forEach(o=>{if(""===r){const[s,c]=o;if(ke(c)){const o=t[s];r=qe(e[s],o,n),delete i[s]}else if(Object.prototype.hasOwnProperty.call(i,s))r=rt(i,s,c),delete i[s];else if(n===q){r=Ve(`Extra key in checked object - (${s}:'${c}')`,"TE@209")}}}),r+=De(i)}function ot(e,t){const n=Ie(t);let r="";if("null"===n||"undefined"===n){r=Ve(`The type '${n}' is not a valid check_type(), `+"check_typeEither(), or check_typeExtra() second parameter type","TE@203")}else if(Ye(n)){const t=ze(e);if(t===n)r="";else if("array"===t){r=Ve(`The value '[]', which is a 'array', is not a '${n}'`,"TE@225")}else if("object"===t){r=Ve(`The value '{}', which is a 'object', is not a '${n}'`,"TE@208")}else if("undefined"===t){r=Ve(`The value 'undefined', is not a '${n}'`,"TE@206")}else{r=Ve(`The value '${Oe(e)}', which is a '${t}', is not a '${n}'`,"TE@226")}}else{if(Ae(e)!==n)if("string"===ze(n))r=function(e){const t=e.replace(/\s+/g,"");let n=Fe(t);n||(n="[]"===t?Ve("The construct '[]' is not a real type, only a container, thus it cannot serve as a signature for EXPECTED TYPE. Try 'array' or ['string'].","TE@222"):"{}"===t?Ve("The construct '{}' is not a real type, only a container, thus it cannot serve as a signature for EXPECTED TYPE. Try 'object' or {a:'string'}.","TE@223"):Ve(`The type '${e}' is not the correct classname or not a scalar type`,"TE@202"));return n}(n);else{r=Ve(`The type '${Oe(n)}' is invalid`,"TE@230")}}return r}function st(e,t,n){let r;return r=ke(t)?qe(e,t,n):ot(e,t)}function ct(e,t){let n;if(0===e.length){n=Ve("Array with with no empty type elements, [], should have at least one empty type element like, ['EMPTY-ERROR']","EE@316")}else{const r=Object.entries(e),[i,o]=r[0];n=Ve(`ELEMENT '${i}' is promised to be a '${o}', but is missing : ${Se(t)}`,"EE@310")}return n}function at(e,t,n,r,i,o){let s;const c=Se(r);if("EMPTY-ERROR"===e||"ER"===e)if(Xe(t)){s=Ve(`ELEMENT '${n}' is erroneously empty :`,"EE@311")}else s="";else if("EMPTY-OK"===e||"OK"===e||"EMPTY-IGNORE"===e||"IG"===e)s=ht(r[n],e,o);else if("string"===ze(e)){s=Ve(`ELEMENT '${n}' is incorrect  type, '${e}', only`+` [ER, EMPTY-ERROR, EMPTY-OK, OK, EMPTY-IGNORE, IG] allowed  : ${c}`,"EE@312")}else s=ht(r[n],e,o);return s}const lt=(e,t,n)=>{let r="";const i=ze(e);if("array"!==i){const t=Oe(e);r=Ve(`Variable ${t} must be an array but is instead a '${i}', : ${t}`,"EE@314")}else e.forEach((e,i)=>{""===r&&(r=1===t.length?ht(e,t,n):ht(e,t[i],n))});return r};const ft=(e,t,n)=>{let r="";const i=Ue(t);return Array.isArray(e)||(e=[e]),e.forEach((e,t)=>{if(""===r){const o=Xe(e);if(ke(i))r=ht(e,i,n);else if(o&&"EMPTY-ERROR"===i)if(b&&"null"===o);else if(b&&"undefined"===o);else{const n=Oe(e);r=Ve(`ELEMENT '${t}' is asserted to be a '${i}',`+` but is really 'EMPTY' : ${n}`,"EE@306")}}}),r},ut=(e,t,n)=>{let r="";if(Array.isArray(e)||(e=[e]),1===t.length&&e.length>1){const i=t[0];r=ft(e,i,n)}else{let i;i=Array.isArray(e)?e.length:0;const o=t.length,s=Se(e);if(0===i)r=function(e){return Ve(`The parameter array ${e} is empty`,"ME@403")}(s);else if("EMPTY-EXTRAS"!==n&&o>1&&o!==i)r=function(e,t,n,r){return Ve(`The parameter array ${e} does not have the same number of elements as ${Se(t)}. `+` Lengths are different ${n} !== ${r}`,"ME@404")}(s,t,i,o);else{const i=Array.from(t),o=i.length,c=ze(e);"array"!==c?r=function(e,t,n){return Ve(`Variable '${e}' must be an array but is a '${t}', : ${n}`,"EE@313")}(e,c,s):e.forEach((t,s)=>{if(""===r){ze(t);const c=Ke(i,s);ke(c)?r=ht(e[s],c,n):1!==o&&delete i[s];const a=at(c,t,s,e,0,n);a&&(r=a)}}),1!==o&&n!==ee&&e.length!==o&&(r=ct(t,e))}}return r},yt=(e,t,n)=>{let r="";const i=Ue(e);if(i===H){const e=ze(t),o=Ge(e),s=Se(t);if(o){if(Xe(t)){r=Ve(` key '${n}' is a '${e}' which is reputed `+`to be '${i}' but has a value of ${s}`,"EE@301")}}else{r=Ve(`Type cannot be empty '${n}' ${i}' is a ${s} :: ${e}`,"EE@302")}}else if(i!==J&&i!==W){r=Ve(`Bad empty type key, '${Oe(i)}', must be either 'EMPTY-OK', 'EMPTY-ER', 'EMPTY-IG', 'OK', 'ER', or 'IG'`,"EE@303")}return r},pt=(e,t,n)=>{let r="";const i={...t};if(ke(e)){Object.entries(e).forEach(o=>{if(""===r){const[s,c]=o,a=Ue(i[s]);if(ke(c)){const o=Ue(t[s]);if(Xe(c)&&"EMPTY-ERROR"===o){const e=Se(c);r=Ve(`Key '${s}' was understood to be '${o}' but was rather '${e}'`,"EE@309")}else r+=ht(e[s],o,n);delete i[s]}else if(Object.prototype.hasOwnProperty.call(i,s))r=yt(a,c,s),delete i[s];else if(n===te){r=Ve(`Extra key in checked object - (${s}:'${c}')`,"EE@315")}}})}return r+=De(i)};function ht(e,t,n){let r;const i=ze(t);if(void 0===t)r="";else if("array"===i)if("array"===ze(t[0]))r=1===t.length?lt(e,t[0],n):lt(e,t,n);else{r="array"===ze(e)?ut(e,t,n):lt(e,t,n)}else r="object"===i?pt(e,t,n):Et(e,t);return r}function Et(e,t){let n="";const r=Ue(t),i=ze(e);if(r===H){const t=ze(e);if(Ge(t)){if(Xe(e)){"object"===i&&(e="{ }"),n=Ve(`${r} states '${i}' must not `+`be empty for the value ${Oe(e)}`,"EE@307")}}else if("null"===i||"undefined"===i){n=Ve(`A '${i}' cannot be empty, so the state`+` of '${r}' is illegal for the value '${e}'`,"EE@308")}}else if(r!==J&&r!==W){n=Ve(`Must 'EMPTY-OK' or 'EMPTY-ERROR' not '${r}'`,"EE@304")}return n}function $t(e,t,n){let r;return r=ke(t)?ht(e,t,n):Et(e,t)}function dt(e,t,n){let r;if(1!==t.length||t[0]!==J&&"OK"!==t[0])r=$t(e,t,n);else{r=Ve("Completely pointless as checking with ['OK'] or ['EMPTY-OK'] matches everything","EE@305")}return r}function _t(e,t){const[n,r]=e;let i="",o="",s=!1;return r.forEach(e=>{let r=e;if("string"===e){1===n.length&&(r=[e])}const i=dt(n,r,t);""===i?s=!0:o=i}),s||(i=o),i}function gt(e,t){const[n,r]=e,i=[];let o,s=!1;if(r.forEach(e=>{let r=e;if("string"===e){let t=!1;Array.isArray(n)&&1===n.length&&(t=!0),t&&(r=[e])}const o=st(n,r,t);""===o?s=!0:i.push(o)}),s)o="";else{const e=i.shift(),t=i.pop();o=0===i.length?`${e}, ${t}`:1===i.length?`${e}, ${t}, plus 1 more Either error`:`${e}, ${t}, plus  ${i.length} more Either errors`}return o}function bt(e){let t=e;const i=e[0];return Array.isArray(i)&&(t=i),t.forEach(e=>{if("object"==typeof e)n=e;else if("UNDEF-OK"===e)b="UNDEF-OK";else if("DEBUG-CONSOLE-TRACE"===e)k="DEBUG-CONSOLE-TRACE";else if("THROW-EXCEPTIONS"===e)d="THROW-EXCEPTIONS";else if("NO-ERROR-MESSAGES"===e)_="NO-ERROR-MESSAGES";else if("LOG-ERRORS"===e)g="LOG-ERRORS";else if("CONSOLE-COUNT"===e)m="CONSOLE-COUNT";else if("NO-CHECKING"===e);else if("DEBUG-ERROR-TAGS"===e)T="DEBUG-ERROR-TAGS";else if(""!==e){throw Ve(`Not THROW-EXCEPTIONS/LOG-ERRORS/UNDEF-OK/DEBUG-CONSOLE-TRACE/NO-CHECKING, unknown : ${Se(e)}`,"EX@107")}}),r=!!(d||g||_),[d,g,_,b,k,m,T]}function mt(e,t,n,r){return Je(r,Ve(e,t),Te(n))}function Tt(e,t,n,r){let i="";if(2!==e.length){i=Ve(`TypeCzech.${t}() has 2 ${N} not ${e.length}`,"ME@401")}else{const[o,s]=e,c=ze(o),a=ze(s);let l;if(""===(i=function(e,t,n,r,i){let o="",s="",c="";return void 0===t?(s=`TypeCzech.${r}() called with a first parameter of ${e} and a second shape parameter of undefined`,c="TE@218"):null===t&&(s=`TypeCzech.${r}() called with a first parameter of ${e} and a second shape parameter of null`,c="TE@220"),""!==s&&(o=mt(s,c,n,i)),o}(Se(c),s,l="string"==typeof s?s:Se(s),t,n))){const e=Oe(o);if("array"===c&&"array"!==a){const e=o.length>1;if("array"!==s&&"a"!==s&&e){i=mt(function(e,t){const n=Oe(e),r=Ie(t);return"Comparing actual [] parameter, with a"+` value of ${n}, against the expected shape of ${r}. They should be the same type.`+` You cannot compare an array with a non-array; both []s, or both ${r}s`}(o,l),"TE@219",l,n)}else if(r){i=mt("There are no parameters.","ME@408",l,n)}}else if("array"===a&&"array"!==c){i=mt(function(e,t,n){return`Comparing actual '${t}' parameter,`+` with a value of ${Oe(e)}, in relation to the expected shape of ${Ie(n)}. They should be the`+` same type. You cannot compare an array with a non-array; both []s, or both '${t}'s. Or same object keys`}(o,c,l),"TE@217",l,n)}else if("array"===a){if(r){i=mt("There are no parameters to match array signature.","ME@409",l,n)}}else if("object"===a){if("object"!==c){i=Ve(`TypeCzech.${t}() called with '{}' against '!{}'.`+` Contrasting a ${c} type of value ${e}, with '${l}' an ${a}`+` !!! ${c} <> ${a}`,"TE@201")}}else if("string"!==a){i=Ve(`TypeCzech.${t}() called with second parameter not a string such as 'number'.`+` Matching '${e}' with '${l}'.`+` Preferably try TypeCzech.${t}(12, 'number')`,"TE@224")}}}return i}function kt(e,t){let n="";if(2!==e.length){n=Ve(`TypeCzech.${t}() needs 2 parameters, not ${e.length}`,"ME@406")}else{const r=e[1],i=Se(r);if("array"!==ze(r)){n=Ve(`TypeCzech.${t}() called with a second parameter`+` as a non-array shape of ${i}`,"ME@402")}else if(r.length<2){const e=Oe(r);n=Ve(`TypeCzech.${t}()  needs at least 2 choices for an Either, not ${r.length} of ${e}`,"UE@701")}}return n}function Ot(e,t,n){let r=!1;return n||Array.isArray(e)||Array.isArray(t)&&1===t.length&&(r=!0),r}function Ct(e,t){const[n,r,i]=Be(e);let o;const s=dt(n,t,ee);return o=s?Je(Y,s,t):""}function St(e,t){const[n,r,i]=Be(e);let o;const s=st(n,t,Q);return o=s?Je(M,s,t):""}function Rt(e){let t;if(e.length<S)t=e;else{const n=e.substring(0,O),r=e.substring(e.length-C);t=`${n} ${R} ${r}`}return t}function Nt(e,t){let n="";if(e!==t){const[r,i]=function(e,t){let n=0,r=!1;for(;e[n]===t[n];){if(n===e.length||n===t.length){r=!0;break}n+=1}return[n,r]}(e,t),o=e.length,s=t.length;let c,a,l;i?o>s?(c=0===s?D:t,a=e.substring(r),l=D):(c=0===o?D:e,a=D,l=e.substring(r)):(c=0===r?D:e.substring(0,r),a=0===o?D:e.substring(r),l=0===s?D:t.substring(r)),n=function(e,t,n){const r=Rt(e),i=Rt(t),o=Rt(n);return`${Oe(`${X}START-SAME ~ ${r}`)}${Oe(`${X}  PRE-DIFF ~ ${i}`)}${Oe(`${X} POST-DIFF ~ ${o}`)}`}(c,a,l)}return n}bt(e);return t=He(n||!1),{_ParametersCheck:He,_anObjectsType:Ae,_arrayOfOneShape:ft,_arrayOfOneType:et,_aTypeOf:ze,_canBeEmpty:Ge,_className:Re,_collectionToStr:Le,_coloredConsole:me,_consoleError:Ve,_doEitherEmpty:_t,_doEitherShape:gt,_doubleToSingleQuotes:Te,_eitherChecks:kt,_emptyArrayInArray:lt,_emptyArrayTypes:ut,_emptyCheck:dt,_emptyCollectionTypes:pt,_emptyContainer:ht,_emptyError:at,_emptyErrorMess:ct,_emptyKeysChecked:yt,_emptyScalar:Et,_emptyVariable:$t,_functionName:Pe,_getParameters:Be,_isAClass:Ne,_isBuiltInClass:we,_isCollection:ke,_isEmpty:Xe,_isScalar:function(e){return!ke(e)},_isaTypeOf:ve,_isPlainJsType:Ye,_jsonStr:Se,_missingKey:De,_mutateStacks:function(){return Ze(i)},_refDiff:Nt,_shapeArrayTypes:nt,_shapeCollectionTypes:it,_shapeContainer:qe,_shapeErrorMess:Qe,_shapePropertyType:rt,_shapeScalar:ot,_shapeVariable:st,_shortToLongEmpty:Ue,_shortToLongType:Ie,_shrinkDiffs:Rt,_specParameters:bt,_stringifyReplacer:Ce,_toStr:Oe,_twoArrays:Tt,_typeFromArray:Ke,_wrongType:tt,_cycle_loops:We,_fast_json_stable_stringify:Ze,TYPE_CZECH_EVENTS:be,assert_check:function(e,n,r,i){return t.p_call_traps&&e?t.assert_check_(e,n,r,i):""},check_type:function(e,n){if(t.p_call_traps){const[t,r,i]=Be(e),o=Oe(t),s=Oe(n);let c=Tt([t,n],"check_type",j,r);if(""===c&&(Ot(e,n,i)&&(c=[j,`VE@603 - Use check_typeVariadic(${o}, ${s}) instead of check_type()`,n]),""===c)){const e=st(t,n,q);c=e?Je(j,e,n):""}return c}},check_typeEither:function(e,n){if(t.p_call_traps){const[t,r,i]=Be(e);let o=kt([t,n],"check_typeEither");if(""===o){const e=gt([t,n],q);o=e?Je(x,e,n):""}return o}},check_typeExtra:function(e,n){if(t.p_call_traps){const t=ke(e),r=ke(n);let i;const o=Oe(n),[s,c,a]=Be(e),l=Oe(s);if(Array.isArray(n)&&1===n.length){const e=Oe(n[0]);let t=`TypeCzech.check_typeExtra(${l}, ${o}) ${`try [${e}, ${e}]`} as ${o} is illegal.`;t=Ve(t,"TE@234"),i=Je(M,t,n)}else if(t&&r)if("string"===Me(n))i=St(e[0],n);else if("object"===Me(n))i=St(e,n);else if(s.length<2){let e=`TypeCzech.check_typeExtra(${l}, ${o}) needs each array to have at least two types to work`;e=Ve(e,"TE@228"),i=Je(M,e,n)}else i=St(e,n);else{let t=`TypeCzech.check_typeExtra(${Oe(e)}, ${o}) needs two collections to work`;t=Ve(t,"TE@227"),i=Je(M,t,n)}return i}},check_typeVariadic:function(e,n){if(t.p_call_traps){let[t,r,i]=Be(e);const o=Oe(t),s=Oe(n);let c;if(Array.isArray(n)){if(1!==n.length){let e=`Use check_type(${o}, ${s}) instead of check_typeVariadic()`;e=Ve(e,"VE@602"),c=[P,e,n]}else if(i&&(t=[t]),""===(c=Tt([t,n],"check_type",P,r))){const e=st(t,n,q);c=e?Je(P,e,n):""}}else{let e=`Use check_typeVariadic(${o}, ['${s}']') instead of check_typeVariadic(${o}, '${s}')`;e=Ve(e,"VE@601"),c=[P,e,n]}return c}},check_empty:function(e,n){if(t.p_call_traps){const[t,r,i]=Be(e),o=Oe(t),s=Oe(n);let c=Tt([t,n],"check_empty",z,r);if(Ot(e,n,i))return[z,`VE@604 - Use check_emptyVariadic([${o}], ['${s}']') instead of check_empty()`,n];if(""===c){const e=dt(t,n,te);c=e?Je(z,e,n):""}return c}},check_emptyEither:function(e,n){if(t.p_call_traps){const[t,r,i]=Be(e);let o=kt([t,n],"check_emptyEither");if(""===o){const e=_t([t,n],te);o=e?Je(I,e,n):""}return o}},check_emptyExtra:function(e,n){if(t.p_call_traps){const t=ke(e),r=ke(n);let i;const o=Oe(n),[s,c,a]=Be(e),l=Oe(s);if(Array.isArray(n)&&1===n.length){const e=Oe(n[0]);let t=`TypeCzech.check_emptyExtra(${l}, ${o}) ${`try [${e}, ${e}]`} as ${o} is prohibited.`;t=Ve(t,"TE@235"),i=Je(M,t,n)}else if(t&&r)if("string"===Me(n))i=Ct(e[0],n);else if("object"===Me(n))i=Ct(e,n);else if("array"!==ze(s)||"array"!==ze(n)){let e=`TypeCzech.check_emptyExtra(${l}, ${o}) needs two arrays to work`;e=Ve(e,"EE@317"),i=Je(Y,e,n)}else if(s.length<2||n.length<2){let e=`TypeCzech.check_emptyExtra(${l}, ${o}) needs each array to have at least two types to work`;e=Ve(e,"EE@318"),i=Je(Y,e,n)}else i=Ct(e,n);else{let t=`TypeCzech.check_emptyExtra(${Oe(e)}, ${o}) needs two collections to work`;t=Ve(t,"TE@31"),i=Je(Y,t,n)}return i}},check_emptyVariadic:function(e,n){if(t.p_call_traps){let[t,r,i]=Be(e);const o=Oe(t),s=Oe(n);let c;if(Array.isArray(n)){if(1!==n.length)c=[w,`VE@606 - Use check_empty(${o}, ${s}) instead of check_emptyVariadic()`,n];else if(i&&(t=[t]),""===(c=Tt([t,n],"check_empty",w,r))){const e=dt(t,n,te);c=e?Je(w,e,n):""}}else c=[w,`VE@605 - Use check_emptyVariadic(${o}, ['${s}']') instead of check_emptyVariadic(${o}, '${s}')`,n];return c}},check_interface:function(e,n){if(t.p_call_traps){const[t,r,i]=Be(e),o=ze(n);let s="";if(xe(t,"Object"))if("object"!==o){let e="Signature is not an object.";e=Ve(e,"IE@504"),s=Je(A,e,n)}else if(0===Object.keys(n).length){let e="Signature is empty object.";e=Ve(e,"IE@503"),s=Je(A,e,n)}else{for(const e in n)if(!s){const r=Ie(n[e]),i=t[e],o=ze(i);void 0===i?s=Ve(`Interface missing key '${e}' in checked object`,"IE@501"):r!==o&&(s=Ve(`actual type of '${e}' is '${o}', with a value `+`of '${Oe(i)}', not the expected '${Oe(r)}' type`,"IE@502"))}s&&(s=Je(A,s,n))}else{let e="Function argument is not an object.";e=Ve(e,"IE@505"),s=Je(A,e,n)}return s}},check_buildSnapshot:function(e,n,r){if(t.p_call_traps){const t=arguments.length;if(3!==t)throw Ve(`TypeCzech.check_buildSnapshot() needs 3 parameters, not ${t}`,"EX@108");if(!ke(r))throw Ve(`TypeCzech.check_buildSnapshot()'s 3rd parameter is not an array/object but instead a '${ze(r)}'`,"EX@109");if("string"!=typeof e)throw Ve(`First TypeCzech.check_buildSnapshot() parameter must be an un-empty string, not ${Oe(e)}`,"EX@110");if("string"!=typeof n)throw Ve(`Second TypeCzech.check_buildSnapshot() parameter must be an un-empty string, not ${Oe(n)}`,"EX@111");const o=`${e}-${n}`,s={func_name:e,var_name:n,collection_ref:r,pre_collect_str:Ze(We.decycle(r))};return i[o]?i[o].push(s):i[o]=[s],""}},check_mutatedSnapshot:function(e,n){if(t.p_call_traps){const t=Oe(e),r=Oe(n),o=`${t}-${r}`;let s="";const c=i[o],a=arguments.length;if(2!==a)throw Ve(`TypeCzech.check_mutatedSnapshot() needs 2 parameters, not ${a}`,"EX@112");if(!c)throw Ve(`No record of an entry for TypeCzech.check_mutatedSnapshot('${t}', '${r}', a_var)`,"EX@113");{const c=i[o].pop();if(void 0===c)throw Ve(`TypeCzech.check_mutatedSnapshot() has no current matching entry for check_buildSnapshot('${t}', '${r}', a_var)`,"EX@114");const{collection_ref:a,pre_collect_str:l}=c,f=Ze(We.decycle(a));if(l===f);else{const t=Oe(l),r=Oe(f),i=`The reference variable '${n}' in function '${e}()' changed values`,o=Rt(t),c=Rt(r),a=Ve(`${i}${`${X}from ${o}`}${`${X}  to ${c} ${X}`}${Nt(l,f)}`,"ME@405");s=Je(v,a,"")}}return Ze(We.decycle(i)),s}},enableChecks:function(){return t.enableChecks_()},disableChecks:function(){return t.disableChecks_()},countFails:function(){return t.countFails_()},countTally:function(){return t.countTally_()},isActive:function(){return r},linkUp:function(e,n,r){let i;return i=void 0===r?t.confirmParameters(e,n,!1):t.confirmParameters(e,n,r)},typeFinal:Me,typeIsA:xe,typeProtos:je}}}}(the_exports="undefined"==typeof exports?window:exports);