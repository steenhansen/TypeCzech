'use strict';let the_exports;the_exports="undefined"===typeof exports?window:exports;if("undefined"===typeof TYPE_CZECH_current_test_number)var TYPE_CZECH_current_test_number="no test number assigned yet";
(function(O){O.TypeCzech=function(){function Ga(...ea){function P(a,b){a=C(a);a=a.substring(1,a.length-1);console.log(`%c ${a}`,b)}function qa(a){return a.replace(/"/g,"'")}function A(a){a=u(a);return"Array"===a?!0:"Object"===a}function q(a){if(A(a))a=Ha(a);else if("undefined"===typeof a)a="undefined";else if("bigint"===typeof a)a=`${a}n`;else if("string"===typeof a)'"Type-Czech-null-Stringify-Valuenull"'===a?a="null":'"Type-Czech-undefined-Stringify-Valueundefined"'===a?a="undefined":'"Type-Czech-NaN-Stringify-ValueNaN"'===
a?a="NaN":(a=a.replace(/string"/g,'"'),a.startsWith('"{')&&a.endsWith('}"')?a=a.substring(1,a.length-1):(a=a.replace(/"$/g,""),a=a.replace(/^"/g,""),0===a.length&&(a="''")));else if("symbol"===typeof a)a=a.toString(),a=a.replace(/\(/g,"('"),a=a.replace(/\)/g,"')");else{const b=C(a);a="object"===typeof a?qa(b):b}return a}function Ia(a,b){return"bigint"===typeof b?`${b}n`:null===b?"Type-Czech-null-Stringify-Valuenull":"undefined"===typeof b?"Type-Czech-undefined-Stringify-Valueundefined":Number.isNaN(b)?
"Type-Czech-NaN-Stringify-ValueNaN":"function"===typeof b?`${String(b).replace(/\s+/g," ").substring(0,30)} ***`:b&&b.constructor===RegExp?`${String(b).substring(0,30)} +++`:"string"===typeof b?`${b}string`:"symbol"===typeof b?q(b):b}function C(a){a=JSON.stringify(a,Ia);return q(a)}function ra(a){let b="";const c=a.toString();c.startsWith("class ")&&c.includes(" constructor(")&&(b=a.name);return b}function Ja(a){let b=!1;null!==a&&"undefined"!==typeof a&&"function"===typeof Object.getPrototypeOf(a)&&
"object"===typeof a.prototype&&ra(a)&&(b=!0);return b}function Ka(a){let b="";a.toString().startsWith("function ")&&(b=a.name);return b}function La(a){var b=!1;null!==a&&"undefined"!==typeof a&&"object"===typeof Object.getPrototypeOf(a)&&(a=a.constructor,b=(b=ra(a))?b:Ka(a));return b}function Ma(a){let b=!1;"string"===typeof a&&sa.includes(a)&&(b=!0);return b}function ta(a){var b=!1;if(null!==a&&"undefined"!==typeof a){const c=[];function d(e){e=Object.getPrototypeOf(e);null!==e&&(c.push(e.constructor.name),
d(e))}b=Object.getPrototypeOf(a).constructor.name;"Object"!==b&&sa.includes(b)?b=[b]:(d(a),b=c)}else b=null===a?["null"]:["undefined"];return b}function L(a){const b=ta(a);let c=!1;b&&(c=b.shift());c||(c="undefined"===typeof a?"undefined":"null");return c}function Na(a,b){a=ta(a);let c=!1;a&&(c=a.includes(b));return c}function u(a){const b=L(a);return b?b:null===a?"null":a instanceof Date?"Date":a instanceof RegExp?"RegExp":Array.isArray(a)?"Array":typeof a}function ua(a){let b=!1;kb.has(a)?b=!0:
va[a]&&(b=!0);return b}function K(a){return va[a]?va[a]:a}function Q(a){return Oa[a]?Oa[a]:a}function Ha(a){const b=[];if(Array.isArray(a))a.forEach(c=>{const d=q(c);"String"===u(c)?"''"===d?b.push('""'):b.push(`"${d}"`):b.push(d)}),a=`[${b.join()}]`;else{for(const [c,d]of Object.entries(a))a=q(d),a="String"===u(d)?"''"===a?`${c}:""`:`${c}:"${a}"`:`${c}:${a}`,b.push(a);a=`{${b.join()}}`}return a}function h(a,b){return wa&&b?(a=`${b} - ${a}`,xa&&P(a,"background: #ee0; color: #F00"),a):a}function V(a){let b=
"";if(!Ma(a)&&"string"===typeof a){const c=a.toLowerCase();Pa[c]&&(b=h(`The type '${a}' is not a check_type type, but it looks just like '${Pa[c]}'`,"TE@205"))}return b}function ya(a){if(0<Object.keys(a).length){const [b,c]=Object.entries(a)[0];a=V(c);a||(a=q(c),a=h(` The key '${b}', which has a type of '${a}', is missing in the checked object`,"TE@216"))}else a="";return a}function R(a){if(a instanceof Date)var b="Invalid Date"==a;else a instanceof RegExp?b="/(?:)/"===a.toString():Number.isNaN(a)?
b=!0:null==a?b=!0:(b=0===a.length,a="object"===typeof a&&0===Object.keys(a).length,b=b||a);return b}function fa(a,b){let c;1===a.length?[c]=a:c=a[b];return c}function D(a){let b=!1,c=!0;null!==a&&void 0!==a&&"undefined"!==typeof a.length&&"string"!==typeof a&&(0===a.length?(b=!0,a=[]):1===a.length?a=a[0]:(a=Array.from(a),c=!1));return[a,b,c]}function z(a,b,c){c=q(c);return[a,b,c]}function za(a){function b(){return`${W} : ${ha}`}function c(l){const k=[];l.forEach(n=>{const p=L(n);p?k.push(`'${p}'`):
(n=C(n),k.push(n))});return k}function d(l,k,n,p,v){W+=1;ia&&P([W],"background: #ee0; color: #00F");if(l){ha+=1;Qa(b());k=` ${k}() ${n} `;if("string"===typeof l)k=l;else{const [x,t,E]=l;l=c(p);1<l.length?(l=`[${l}]`,p=q(p)):(p=q(p),p=p.substring(1,p.length-1));k=k+t+("\n\t\t"+x);n=" EMPTY ASSERTION";"check_type(arguments, expected_types)"===x||"check_variadicType(arguments, expected_types)"===x||"check_typeExtra(arguments, expected_types)"===x||"check_typeEither(arguments, expected_types)"===x?n=
"   EXPECTED TYPE":"check_mutated(arguments, expected_types)"===x&&(n="");k+=`${"\n\t\t"}${"    ACTUAL TYPES"} ${l}`;k+=`${"\n\t\t"}${"    ACTUAL VALUE"} ${p}`;n&&(k+=`${"\n\t\t"}${n} ${E}`);k+=`${"\n\t\t"}${"CALLING FUNCTION"} ${v}`;k+="\n\t\t"}if(X)throw Error(k);Y&&console.log(k)}}function e(l){l=l.toString().match(lb);const k=`${l[0]})`.replace(/^function /,"");l[2].split(", ").includes("arguments")&&P(`Parameter 'arguments' shadows arguments object : ${l[0]})`,"background: #ee0; color: #00F");
return k}function g(l,k,n){const p=e(n),v=n.apply(null,k);d(v,n.name,l,k,p)}function f(l,k,n,p){const v=e(p);k=p.apply(k,n);d(k,p.name,l,n,v)}function m(l){return"object"===typeof l?`{ ${Object.keys(l).map(k=>`${k}()`).reduce((k,n)=>`${k}, ${n}`)} }`:`${l.name}()`}function r(l,k,n){if("function"!==typeof l&&"object"!==typeof l)throw l=q(l),h(`${k}, is a not a function nor an object that has a value of '${l}'`,n);}function w(l,k){const n=m(k);if(void 0===l)throw h(`The function to be checked by ${n} is 'undefined', maybe namespace issue`,
"EX@102");if(l===k)throw h(`_ParametersCheck you cannot use ${l.name}() to test`+`${k.name}(), they must be different functions`,"EX@103");}function B(l,k,n){const p=l.name;return new Proxy(l,{apply(v,x,t){Z(b());F&&k&&("undefined"===typeof x?g(`${p}${"() "}${"PRE-FUNC:"}`,t,k):f(`${p}${"() "}${"PRE-FUNC:"}`,x,t,k));v=v.apply(x,t);F&&n&&("undefined"===typeof x?g(`${p}${"() "}${"POST-FUNC:"}`,[v],n):f(`${p}${"() "}${"POST-FUNC:"}`,x,[v],n));return v}})}function G(l,k,n,p){const v=new Set;n&&Object.keys(n).forEach(t=>
v.add(t));p&&Object.keys(p).forEach(t=>v.add(t));let x=!1;Object.isFrozen(k)&&(x=!0,k=Object.assign({},k));v.forEach(t=>{if(t!==l){let E=!1;n&&(E=n[t]||!1);let M=!1;p&&(M=p[t]||!1);k[t]&&(k[t]=B(k[t],E,M))}});x&&Object.freeze(k);return k}function H(l,k){return"function"===typeof l?l:"undefined"===typeof l?!1:l[k]}function ja(l,k,n){const p=l.name,v=H(k,p),x=H(n,p);return new Proxy(l,{apply(){},construct(t,E,M){Z(b());F&&v&&g(`${p}${"() "}${"PRE-CLASS:"}`,E,v);t=Reflect.construct(t,E,M);t=G(p,t,k,
n);F&&x&&f(`${p}${"() "}${"POST-CLASS:"}`,t,[t],x);return t}})}function mb(l,k,n){const p=l.name,v=H(k,p),x=H(n,p);return new Proxy(l,{apply(t,E,M){Z(b());F&&v&&g(`${p}${"() "}${"PRE-OBJ:"}`,M,v);t=t.apply(E,M);t=G(p,t,k,n);F&&x&&g(`${p}${"() "}${"PRE-OBJ:"}`,[t],n[p]);return t},construct(t,E){Z(b());F&&v&&g(`${p}${"() "}${"POST-OBJ:"}`,E,v);t=new t(...E);t=G(p,t,k,n);F&&x&&f(`${p}${"() "}${"POST-OBJ:"}`,t,[t],x);return t}})}function nb(l,k,n){var p=arguments.length;if(2!==p&&3!==p)throw h(`TypeCzech.linkUp() needs 2 or 3 parameters, not ${p}`,
"EX@106");if(Ra.has(l))throw h(`${l.name}() is already proxied with ${l.name}`,"EX@104");if("function"!==typeof l){var v=`The first parameter to TypeCzech.linkUp(), target_proxy is not a function, but is instead ${q(l)}`;throw h(v,"EX@105");}if(k)for(var x in k)p=k[x],w(l,p),r(p,"TypeCzech.linkUp() 2nd parameter, PRE-CHECK()","EX@101");if(n)for(v in n)x=n[v],w(l,x),r(x,"TypeCzech.linkUp() 3rd parameter, POST-CHECK()","EX@115");Ja(l)?v=ja(l,k,n):(v=u(k),x=u(n),v="Object"===v||"Object"===x?mb(l,k,n):
B(l,k,n));Ra.add(v);return v}var S=arguments.length;if(1<S)throw h(`TypeCzech._ParametersCheck() - Internal - needs 0 or 1 parameters, not ${S}`,"ME@407");let Z=()=>"",Qa=()=>"",W=0,ha=0,F=!1;S=(l,k,n)=>l;S=ka?nb:S;if(ka){a&&"Object"!==u(a)&&P(["_ParametersCheck - arg_check_events is not an Object with onStart(), onCheck(), onError() ",a],"background: #ee0; color: #F00");"undefined"!==typeof window&&P(["TypeCzech-init","ver 4.0",X?"THROW-EXCEPTIONS":"",Y?"LOG-ERRORS":"",la?"LOG-ERRORS":"",I?"UNDEF-OK":
"",ia?"CONSOLE-COUNT":"",a],"background: #cc0; color: #080");if(void 0!==a.onStart)a.onStart("Start");void 0!==a.onCheck&&(Z=a.onCheck);void 0!==a.onError&&(Qa=a.onError);F=!0}return{confirmParameters:S,countBegin_:function(){F=!0;ha=W=0;return"Start Type-Czech counting at 0"},countTally_:function(){return W},countEnd_:function(){F=!1;return"Stop Type-Czech counting"},countFails_:function(){return ha},directCheck_:function(l,k,n){d(l,k,"",[n],"TypeCzech.directCheck()")},p_call_traps:F}}function aa(a,
b){b||(b={});"function"===typeof b&&(b={cmp:b});var c="boolean"===typeof b.cycles?b.cycles:!1,d=b.cmp&&function(g){return function(f){return function(m,r){return g({key:m,value:f[m]},{key:r,value:f[r]})}}}(b.cmp),e=[];return function m(f){f&&f.toJSON&&"function"===typeof f.toJSON&&(f=f.toJSON());if(Number.isNaN(f))return"NaN";if(void 0===f)return"undefined";if("bigint"===typeof f)return JSON.stringify(f+"n");if("symbol"===typeof f)return f.toString();if("function"===typeof f)return replaced_value=
`${String(f).substring(0,30)} ***`;if(f&&f.constructor===RegExp)return replaced_value=`${String(f).substring(0,30)} +++`;if("number"==typeof f)return isFinite(f)?""+f:"null";if("object"!==typeof f)return JSON.stringify(f);var r;if(Array.isArray(f)){var w="[";for(r=0;r<f.length;r++)r&&(w+=","),w+=m(f[r])||"null";return w+"]"}if(null===f)return"null";if(-1!==e.indexOf(f)){if(c)return JSON.stringify("__cycle__");throw new TypeError("Converting circular structure to JSON");}var B=e.push(f)-1,G=Object.keys(f).sort(d&&
d(f));w="";for(r=0;r<G.length;r++){var H=G[r],ja=m(f[H]);ja&&(w&&(w+=","),w+=JSON.stringify(H)+":"+ja)}e.splice(B,1);return"{"+w+"}"}(a)}function Sa(a,b){a=Object.entries(a);const [c,d]=a[0];b=q(b);return h(`Element '${c}' is supposed to be a '${d}', but is missing : ${b}`,"TE@221")}function ma(a,b,c){let d="";const e=u(a),g=u(b);void 0===b?d="":e!==g?e===b||"TYPE-EXTRAS"===c&&"Array"===g||(a=C(a),b="String"===u(b)?b:g,d=h(`Parameter is meant to be '${b}' but is`+` of the wrong type of '${e}':${a}`,
"TE@207")):"Array"===g?d=Ta(a,b,c):"Object"===g&&(d=Ua(a,b,c));return d}function Ta(a,b,c){let d="";if(1===b.length&&1<a.length)d=Va(a,b[0],c);else{const e=Array.from(b);b=e.length;a.forEach((g,f)=>{if(""===d){const m=u(g),r=fa(e,f);A(r)?d=ma(g,r,c):(g=K(fa(e,f)),g===m||"TYPE-EXTRAS"===c&&void 0===g||I&&"null"===m||I&&"undefined"===m||(d=Wa(g,f,m)));delete e[f]}});d||1!==b&&a.length<b&&(d=Sa(e,a))}return d}function Ua(a,b,c){let d="";const e={...b};Object.entries(a).forEach(g=>{if(""===d){const [f,
m]=g;A(m)?(d=ma(a[f],b[f],c),delete e[f]):Object.prototype.hasOwnProperty.call(e,f)?(d=Xa(e,f,m),delete e[f]):"TYPE-VERIFY"===c&&(d=h(`Extra key in checked object - (${f}:'${m}')`,"TE@209"))}});return d+=ya(e)}function Ya(a,b){b=K(b);var c="";"null"===b||"undefined"===b?c=h(`The type '${b}' is not a valid check_type(), `+"check_typeEither(), or check_typeExtra() second parameter type","TE@203"):ua(b)?(c=u(a),c===b?c="":"Array"===c?c=h(`The value '[]', which is a 'Array', is not a '${b}'`,"TE@225"):
"Object"===c?c=h(`The value '{}', which is a 'Object', is not a '${b}'`,"TE@208"):"undefined"===c?c=h(`The value 'undefined', is not a '${b}'`,"TE@206"):(b=`The value '${q(a)}', which is a '${c}', is not a '${b}'`,c=h(b,"TE@226"))):La(a)!==b&&("string"===u(b)?(a=b.replace(/\s+/g,""),(c=V(a))||(c="[]"===a?h("The construct '[]' is not a real type, only a container, thus it cannot serve as a signature for EXPECTED TYPE. Try 'Array' or ['String'].","TE@222"):"{}"===a?h("The construct '{}' is not a real type, only a container, thus it cannot serve as a signature for EXPECTED TYPE. Try 'Object' or {a:'String'}.",
"TE@223"):h(`The type '${b}' is not the correct classname or not a scalar type`,"TE@202"))):(b=`The type '${q(b)}' is invalid`,c=h(b,"TE@230")));return c}function T(a,b,c){return A(b)?ma(a,b,c):Ya(a,b)}function Za(a,b){if(0===a.length)b=h("Array with with no empty type elements, [], should have at least one empty type element like, ['EMPTY-ERROR']","EE@316");else{a=Object.entries(a);const [c,d]=a[0];b=C(b);b=h(`ELEMENT '${c}' is promised to be a '${d}', but is missing : ${b}`,"EE@310")}return b}function $a(a,
b,c,d,e,g){e=C(d);return"EMPTY-ERROR"===a||"ER"===a?R(b)?h(`ELEMENT '${c}' is erroneously empty :`,"EE@311"):"":"EMPTY-OK"===a||"OK"===a||"EMPTY-IGNORE"===a||"IG"===a?J(d[c],a,g):"String"===u(a)?h(`ELEMENT '${c}' is incorrect  type, '${a}', only`+` [ER, EMPTY-ERROR, EMPTY-OK, OK, EMPTY-IGNORE, IG] allowed  : ${e}`,"EE@312"):J(d[c],a,g)}function ob(a,b,c,d){b=C(b);return h(`The parameter array ${a} does not have the same number of elements as ${b}. `+` Lengths are different ${c} !== ${d}`,"ME@404")}
function J(a,b,c){const d=u(b);return void 0===b?"":"Array"===d?"Array"===u(b[0])?1===b.length?na(a,b[0],c):na(a,b,c):"Array"===u(a)?ab(a,b,c):na(a,b,c):"Object"===d?bb(a,b,c):Aa(a,b)}function Aa(a,b){let c="";b=Q(b);const d=u(a);if("EMPTY-ERROR"===b){const e=u(a);if(Ba(e))R(a)&&("Object"===d&&(a="{ }"),c=h(`${b} states '${d}' must not `+`be empty for the value '${a}'`,"EE@307"));else if("null"===d||"undefined"===d)c=h(`A '${d}' cannot be empty, so the state`+` of '${b}' is illegal for the value '${a}'`,
"EE@308")}else"EMPTY-OK"!==b&&"EMPTY-IGNORE"!==b&&(c=h(`Must 'EMPTY-OK' or 'EMPTY-ERROR' not '${b}'`,"EE@304"));return c}function cb(a,b,c){return A(b)?J(a,b,c):Aa(a,b)}function ba(a,b,c){return 1!==b.length||"EMPTY-OK"!==b[0]&&"OK"!==b[0]?cb(a,b,c):h("Completely pointless as checking with ['OK'] or ['EMPTY-OK'] matches everything","EE@305")}function db(a,b){const [c,d]=a;let e=a="",g=!1;d.forEach(f=>{let m=f;"String"===f&&1===c.length&&(m=[f]);f=ba(c,m,b);""===f?g=!0:e=f});g||(a=e);return a}function eb(a,
b){const [c,d]=a,e=[];let g=!1;d.forEach(f=>{let m=f;if("String"===f){let r=!1;Array.isArray(c)&&1===c.length&&(r=!0);r&&(m=[f])}f=T(c,m,b);""===f?g=!0:e.push(f)});if(g)a="";else{a=e.shift();const f=e.pop();a=0===e.length?`${a}, ${f}`:1===e.length?`${a}, ${f}, plus 1 more Either error`:`${a}, ${f}, plus  ${e.length} more Either errors`}return a}function fb(a){let b=a;a=a[0];Array.isArray(a)&&(b=a);b.forEach(c=>{if("object"===typeof c)Ca=c;else if("UNDEF-OK"===c)I="UNDEF-OK";else if("DEBUG-CONSOLE-TRACE"===
c)xa="DEBUG-CONSOLE-TRACE";else if("THROW-EXCEPTIONS"===c)X="THROW-EXCEPTIONS";else if("NO-ERROR-MESSAGES"===c)la="NO-ERROR-MESSAGES";else if("LOG-ERRORS"===c)Y="LOG-ERRORS";else if("CONSOLE-COUNT"===c)ia="CONSOLE-COUNT";else if("NO-CHECKING"!==c)if("DEBUG-ERROR-TAGS"===c)wa="DEBUG-ERROR-TAGS";else if(""!==c)throw c=`Not THROW-EXCEPTIONS/LOG-ERRORS/UNDEF-OK/DEBUG-CONSOLE-TRACE/NO-CHECKING, unknown : ${C(c)}`,h(c,"EX@107");});ka=!!(X||Y||la);return[X,Y,la,I,xa,ia,wa]}function ca(a,b,c,d){a=h(a,b);
c=qa(c);return z(d,a,c)}function da(a,b,c,d){if(2!==a.length)var e=h(`TypeCzech.${b}() has 2 ${"arguments"} not ${a.length}`,"ME@401");else{const [f,m]=a;var g=u(f);const r=u(m),w=C(g);a="string"===typeof m?m:C(m);let B=e="",G="";"undefined"===typeof m?(B=`TypeCzech.${b}() called with a first parameter of ${w} and a second shape parameter of undefined`,G="TE@218"):null===m&&(B=`TypeCzech.${b}() called with a first parameter of ${w} and a second shape parameter of null`,G="TE@220");""!==B&&(e=ca(B,
G,a,c));""===e&&("Array"===g&&"Array"!==r?(b=1<f.length,"Array"!==m&&"A"!==m&&b?(b=a,d=q(f),b=K(b),e=ca("Comparing actual [] parameter, with a"+` value of ${d}, against the expected shape of ${b}. They should be the same type.`+` You cannot compare an array with a non-array; both []s, or both ${b}s`,"TE@219",a,c)):d&&(e=ca("There are no parameters.","ME@408",a,c))):"Array"===r&&"Array"!==g?(d=g,g=a,b=q(f),g=K(g),e=ca(`Comparing actual '${d}' parameter,`+` with a value of ${b}, in relation to the expected shape of ${g}. They should be the`+
` same type. You cannot compare an array with a non-array; both []s, or both '${d}'s. Or same object keys`,"TE@217",a,c)):"Array"===r?d&&(e=ca("There are no parameters.","ME@409",a,c)):"Object"===r?"Object"!==g&&(e=h(`TypeCzech.${b}() called with '{}' against '!{}'.`+` Contrasting ${w}, a '${g}' type, with '${a}' an ${r}`,"TE@201")):"String"!==r&&(e=h(`TypeCzech.${b}() called with second parameter not a string such as 'Number'.`+` Matching '${w}' with '${a}'.`+` Preferably try TypeCzech.${b}(12, 'Number')`,
"TE@224")))}return e}function Da(a,b){var c="";if(2!==a.length)c=h(`TypeCzech.${b}() needs 2 parameters, not ${a.length}`,"ME@406");else{a=a[1];const d=C(a);"Array"!==u(a)?c=h(`TypeCzech.${b}() called with a second parameter`+` as a non-array shape of ${d}`,"ME@402"):2>a.length&&(c=q(a),c=h(`TypeCzech.${b}()  needs at least 2 choices for a union, not ${a.length} of ${c}`,"UE@701"))}return c}function gb(a,b,c){let d=!1;c||Array.isArray(a)||Array.isArray(b)&&1===b.length&&(d=!0);return d}function Ea(a,
b){[a]=D(a);return(a=ba(a,b,"EMPTY-EXTRAS"))?z("check_emptyExtra(arguments, expected_emptys)",a,b):""}function Fa(a,b){[a]=D(a);return(a=T(a,b,"TYPE-EXTRAS"))?z("check_typeExtra(arguments, expected_types)",a,b):""}function U(a){if(160>a.length)var b=a;else b=a.substring(0,100),a=a.substring(a.length-50),b=`${b} ${"<<<<<<~~~>>>>>>"} ${a}`;return b}function hb(a,b){var c="";if(a!==b){c=0;for(var d=!1;a[c]===b[c];){if(c===a.length||c===b.length){d=!0;break}c+=1}const [g,f]=[c,d];var e=a.length;d=b.length;
f?e>d?(c=0===d?"''":b,e=a.substring(g),b="''"):(c=0===e?"''":a,e="''",b=a.substring(g)):(c=0===g?"''":a.substring(0,g),e=0===e?"''":a.substring(g),b=0===d?"''":b.substring(g));a=e;c=U(c);a=U(a);b=U(b);c=q(`${"\n\t\t"}START-SAME ~ ${c}`);a=q(`${"\n\t\t"}  PRE-DIFF ~ ${a}`);b=q(`${"\n\t\t"} POST-DIFF ~ ${b}`);c=`${c}${a}${b}`}return c}let y,Ca=!1,ka=!1;const N={},Ra=new WeakSet;let X=!1,la=!1,Y=!1,I=!1,ia=!1,wa=!1,xa=!1;const lb=/([^(]*\()([^)]*)/,Oa={OK:"EMPTY-OK",ER:"EMPTY-ERROR",IG:"EMPTY-IGNORE"},
sa="Array BigInt Boolean Date Function Number Object RegExp String Symbol".split(" "),Pa={array:"Array",bigint:"BigInt",boolean:"Boolean",date:"Date",function:"Function",number:"Number",object:"Object",regexp:"RegExp",string:"String",symbol:"Symbol"},kb=new Set(sa),va={A:"Array",I:"BigInt",B:"Boolean",D:"Date",F:"Function",N:"Number",O:"Object",R:"RegExp",S:"String",Y:"Symbol"},oa={backBlink:a=>{document.body.style.background=a;setTimeout(()=>{document.body.style.background="white"},100)},onStart:()=>
oa.backBlink("green"),onCheck:()=>oa.backBlink("blue"),onError:()=>oa.backBlink("red")},Ba=a=>"Array"===a?!0:"Object"===a?!0:"String"===a?!0:"RegExp"===a?!0:"Date"===a?!0:"Number"===a,pa={decycle:function(a,b){var c=new WeakMap;return function f(e,g){void 0!==b&&(e=b(e));if(!("object"!==typeof e||null===e||e instanceof Boolean||e instanceof Date||e instanceof Number||e instanceof RegExp||e instanceof String)){var m=c.get(e);if(void 0!==m)return{$ref:m};c.set(e,g);if(Array.isArray(e)){var r=[];e.forEach(function(w,
B){r[B]=f(w,g+"["+B+"]")})}else r={},Object.keys(e).forEach(function(w){r[w]=f(e[w],g+"["+JSON.stringify(w)+"]")});return r}return e}(a,"$")}},Va=(a,b,c)=>{let d="";const e=K(b);Array.isArray(a)||(a=[a]);a.forEach((g,f)=>{if(""===d){const m=u(g);if(A(e))d=T(g,e,c);else if(!(e===m||I&&"null"===m||I&&"undefined"===m)){let r=V(e);r||(g=q(g),r=h(`ELEMENT '${f}' is asserted to be a '${e}',`+` but is fallaciously a '${m}' : ${g}`,"TE@215"));d=r}}});return d},Wa=(a,b,c)=>{var d="";"null"===a?d=h(` ELEMENT '${b}' type is invalid 'null'`,
"TE@204"):"undefined"===a?d=h(` ELEMENT '${b}' type is invalid 'undefined'`,"TE@229"):"string"!==typeof a&&(d=q(a),d=h(` ELEMENT '${b}' type is invalid as it is not a string but instead ${d}`,"TE@230"));d||(d=V(a))||(d=h(` ELEMENT '${b}' is assumed to be a '${a}',`+` but is mistakenly a '${c}'`,"TE@214"));return d},Xa=(a,b,c)=>{let d="";a=K(a[b]);if(ua(a)){const e=u(c);a===e||I&&"null"===e||I&&"undefined"===e||("undefined"===typeof c?d=h(`Key '${b}' was given to be a '${a}' but was instead 'undefined'`,
"TE@211"):"null"===e?d=h(`Key '${b}' was determined to be a '${a}' but was instead 'null'`,"TE@212"):(c=q(c),d=h(`Property '${b}' is indicated to be a '${a}',`+` but is inaccurately a '${e}' : ${c}`,"TE@213")))}else d=V(a),d||(b=`The type '${C(a)}' is not a real type`,d=h(b,"TE@210"));return d},na=(a,b,c)=>{let d="";const e=u(a);"Array"!==e?(a=q(a),d=h(`Variable ${a} must be an array but is instead a '${e}', : ${a}`,"EE@314")):a.forEach((g,f)=>{""===d&&(d=1===b.length?J(g,b,c):J(g,b[f],c))});return d},
ib=(a,b,c)=>{let d="";const e=Q(b);Array.isArray(a)||(a=[a]);a.forEach((g,f)=>{if(""===d){const m=R(g);A(e)?d=J(g,e,c):!m||"EMPTY-ERROR"!==e||I&&"null"===m||I&&"undefined"===m||(g=q(g),d=h(`ELEMENT '${f}' is asserted to be a '${e}',`+` but is really 'EMPTY' : ${g}`,"EE@306"))}});return d},ab=(a,b,c)=>{let d="";Array.isArray(a)||(a=[a]);if(1===b.length&&1<a.length)d=ib(a,b[0],c);else{var e=Array.isArray(a)?a.length:0;const g=b.length,f=C(a);if(0===e)d=h(`The parameter array ${f} is empty`,"ME@403");
else if("EMPTY-EXTRAS"!==c&&1<g&&g!==e)d=ob(f,b,e,g);else{const m=Array.from(b),r=m.length;e=u(a);"Array"!==e?d=h(`Variable '${a}' must be an array but is a '${e}', : ${f}`,"EE@313"):a.forEach((w,B)=>{if(""===d){const G=u(w),H=fa(m,B);A(H)?d=J(a[B],H,c):1!==r&&delete m[B];(w=$a(H,w,B,a,G,c))&&(d=w)}});1!==r&&"EMPTY-EXTRAS"!==c&&a.length!==r&&(d=Za(b,a))}}return d},jb=(a,b,c)=>{let d="";a=Q(a);if("EMPTY-ERROR"===a){const e=u(b),g=Ba(e),f=C(b);g?R(b)&&(d=h(` key '${c}' is a '${e}' which is reputed `+
`to be '${a}' but has a value of ${f}`,"EE@301")):d=h(`Type cannot be empty '${c}' ${a}' is a ${f} :: ${e}`,"EE@302")}else"EMPTY-OK"!==a&&"EMPTY-IGNORE"!==a&&(b=`Bad empty type key, '${q(a)}', must be either 'EMPTY-OK', 'EMPTY-ER', 'EMPTY-IG', 'OK', 'ER', or 'IG'`,d=h(b,"EE@303"));return d},bb=(a,b,c)=>{let d="";const e={...b};A(a)&&Object.entries(a).forEach(g=>{if(""===d){const [f,m]=g;g=Q(e[f]);if(A(m)){g=Q(b[f]);if(R(m)&&"EMPTY-ERROR"===g){const r=C(m);d=h(`Key '${f}' was understood to be '${g}' but was rather '${r}'`,
"EE@309")}else d+=J(a[f],g,c);delete e[f]}else Object.prototype.hasOwnProperty.call(e,f)?(d=jb(g,m,f),delete e[f]):"EMPTY-VERIFY"===c&&(d=h(`Extra key in checked object - (${f}:'${m}')`,"EE@315"))}});return d+=ya(e)};fb(ea);y=Ca?za(Ca):za(!1);return{_ParametersCheck:za,_anObjectsType:La,_arrayOfOneShape:ib,_arrayOfOneType:Va,_aTypeOf:u,_canBeEmpty:Ba,_className:ra,_collectionToStr:Ha,_coloredConsole:P,_consoleError:h,_doEitherEmpty:db,_doEitherShape:eb,_doubleToSingleQuotes:qa,_eitherChecks:Da,_emptyArrayInArray:na,
_emptyArrayTypes:ab,_emptyCheck:ba,_emptyCollectionTypes:bb,_emptyContainer:J,_emptyError:$a,_emptyErrorMess:Za,_emptyKeysChecked:jb,_emptyScalar:Aa,_emptyVariable:cb,_functionName:Ka,_getParameters:D,_isAClass:Ja,_isBuiltInType:Ma,_isCollection:A,_isEmpty:R,_isScalar:function(a){return!A(a)},_isPlainJsType:ua,_jsonStr:C,_missingKey:ya,_mutateStacks:function(){return aa(N)},_refDiff:hb,_shapeArrayTypes:Ta,_shapeCollectionTypes:Ua,_shapeContainer:ma,_shapeErrorMess:Sa,_shapePropertyType:Xa,_shapeScalar:Ya,
_shapeVariable:T,_shortToLongEmpty:Q,_shortToLongType:K,_shrinkDiffs:U,_specParameters:fb,_stringifyReplacer:Ia,_toStr:q,_twoArrays:da,_typeFromArray:fa,_wrongType:Wa,_cycle_loops:pa,_fast_json_stable_stringify:aa,TYPE_CZECH_EVENTS:oa,check_empty:function(a,b){if(y.p_call_traps){const [c,d,e]=D(a),g=q(c),f=q(b);let m=da([c,b],"check_empty","check_empty(arguments, expected_emptys)",d);if(gb(a,b,e))return["check_empty(arguments, expected_emptys)",`VE@604 - Use check_variadicEmpty([${g}], ['${f}']') instead of check_empty()`,
b];""===m&&(m=(a=ba(c,b,"EMPTY-VERIFY"))?z("check_empty(arguments, expected_emptys)",a,b):"");return m}},check_emptyEither:function(a,b){if(y.p_call_traps){[a]=D(a);let c=Da([a,b],"check_emptyEither");""===c&&(c=(a=db([a,b],"EMPTY-VERIFY"))?z("check_emptyEither(arguments, expected_emptys)",a,b):"");return c}},check_emptyExtra:function(a,b){if(y.p_call_traps){var c=A(a),d=A(b);const e=q(b);c&&d?([c]=D(a),d=q(c),"String"===L(b)?b=Ea(a[0],b):"Object"===L(b)?b=Ea(a,b):"Array"!==u(c)||"Array"!==u(b)?(a=
`TypeCzech.check_emptyExtra(${d}, ${e}) needs two arrays to work`,a=h(a,"EE@317"),b=z("check_emptyExtra(arguments, expected_emptys)",a,b)):2>c.length||2>b.length?(a=`TypeCzech.check_emptyExtra(${d}, ${e}) needs each array to have at least two types to work`,a=h(a,"EE@318"),b=z("check_emptyExtra(arguments, expected_emptys)",a,b)):b=Ea(a,b)):(a=`TypeCzech.check_emptyExtra(${q(a)}, ${e}) needs two collections to work`,a=h(a,"TE@31"),b=z("check_emptyExtra(arguments, expected_emptys)",a,b));return b}},
check_interface:function(a,b){if(y.p_call_traps){[a]=D(a);var c=u(b),d="";if(Na(a,"Object"))if("Object"!==c){var e=h("Signature is not an object.","IE@504");d=z("check_interface(arguments, expected_types)",e,b)}else if(0===Object.keys(b).length)e=h("Signature is empty object.","IE@503"),d=z("check_interface(arguments, expected_types)",e,b);else{for(e in b)if(!d){var g=K(b[e]);const f=a[e];c=u(f);"undefined"===typeof f?d=h(`Interface missing key '${e}' in checked object`,"IE@501"):g!==c&&(d=q(f),g=
q(g),d=h(`actual type of '${e}' is '${c}', with a value `+`of '${d}', not the expected '${g}' type`,"IE@502"))}d&&(d=z("check_interface(arguments, expected_types)",d,b))}else e=h("Function argument is not an object.","IE@505"),d=z("check_interface(arguments, expected_types)",e,b);return d}},check_mutated:function(a,b){if(y.p_call_traps){var c=q(a),d=q(b),e=`${c}-${d}`,g="",f=N[e];const m=arguments.length;if(2!==m)throw h(`TypeCzech.check_mutated() needs 2 parameters, not ${m}`,"EX@112");if(f){e=N[e].pop();
if("undefined"===typeof e)throw h(`TypeCzech.check_mutated() has no current matching entry for mutateSnapshot('${c}', '${d}', a_var)`,"EX@114");const {collection_ref:r,pre_collect_str:w}=e;c=pa.decycle(r);c=aa(c);w!==c&&(e=q(w),d=q(c),g=`The reference variable '${b}' in function '${a}()' changed values`,e=U(e),f=U(d),d=`${"\n\t\t"}from ${e}`,e=`${"\n\t\t"}  to ${f} ${"\n\t\t"}`,c=hb(w,c),g=h(`${g}${d}${e}${c}`,"ME@405"),g=z("check_mutated(arguments, expected_types)",g,""))}else throw h(`No record of an entry for TypeCzech.check_mutated('${c}', '${d}', a_var)`,
"EX@113");c=pa.decycle(N);aa(c);return g}},check_type:function(a,b){if(y.p_call_traps){const [c,d,e]=D(a),g=q(c),f=q(b);let m=da([c,b],"check_type","check_type(arguments, expected_types)",d);""===m&&(gb(a,b,e)&&(m=["check_type(arguments, expected_types)",`VE@603 - Use check_variadicType(${g}, ${f}) instead of check_type()`,b]),""===m&&(m=(a=T(c,b,"TYPE-VERIFY"))?z("check_type(arguments, expected_types)",a,b):""));return m}},check_typeEither:function(a,b){if(y.p_call_traps){[a]=D(a);let c=Da([a,b],
"check_typeEither");""===c&&(c=(a=eb([a,b],"TYPE-VERIFY"))?z("check_typeEither(arguments, expected_types)",a,b):"");return c}},check_typeExtra:function(a,b){if(y.p_call_traps){var c=A(a),d=A(b);const e=q(b);c&&d?([c]=D(a),d=q(c),"String"===L(b)?b=Fa(a[0],b):"Object"===L(b)?b=Fa(a,b):2>c.length?(a=`TypeCzech.check_typeExtra(${d}, ${e}) needs each array to have at least two types to work`,a=h(a,"TE@228"),b=z("check_typeExtra(arguments, expected_types)",a,b)):b=Fa(a,b)):(a=`TypeCzech.check_typeExtra(${q(a)}, ${e}) needs two collections to work`,
a=h(a,"TE@227"),b=z("check_typeExtra(arguments, expected_types)",a,b));return b}},check_variadicEmpty:function(a,b){if(y.p_call_traps){let [c,d,e]=D(a);a=q(c);const g=q(b);Array.isArray(b)?1!==b.length?a=["check_variadicEmpty(arguments, expected_types)",`VE@606 - Use check_empty(${a}, ${g}) instead of check_variadicEmpty()`,b]:(e&&(c=[c]),a=da([c,b],"check_empty","check_variadicEmpty(arguments, expected_types)",d),""===a&&(a=(a=ba(c,b,"EMPTY-VERIFY"))?z("check_variadicEmpty(arguments, expected_types)",
a,b):"")):a=["check_variadicEmpty(arguments, expected_types)",`VE@605 - Use check_variadicEmpty(${a}, ['${g}']') instead of check_variadicEmpty(${a}, '${g}')`,b];return a}},check_variadicType:function(a,b){if(y.p_call_traps){let [c,d,e]=D(a);a=q(c);const g=q(b);Array.isArray(b)?1!==b.length?(a=`Use check_type(${a}, ${g}) instead of check_variadicType()`,a=h(a,"VE@602"),a=["check_variadicType(arguments, expected_types)",a,b]):(e&&(c=[c]),a=da([c,b],"check_type","check_variadicType(arguments, expected_types)",
d),""===a&&(a=(a=T(c,b,"TYPE-VERIFY"))?z("check_variadicType(arguments, expected_types)",a,b):"")):(a=`Use check_variadicType(${a}, ['${g}']') instead of check_variadicType(${a}, '${g}')`,a=h(a,"VE@601"),a=["check_variadicType(arguments, expected_types)",a,b]);return a}},countBegin:function(){return y.countBegin_()},countEnd:function(){return y.countEnd_()},countFails:function(){return y.countFails_()},countTally:function(){return y.countTally_()},directCheck:function(a,b,c){return y.p_call_traps&&
a?y.directCheck_(a,b,c):""},isActive:function(){return ka},linkUp:function(a,b,c){return"undefined"===typeof c?y.confirmParameters(a,b,!1):y.confirmParameters(a,b,c)},mutateSnapshot:function(a,b,c){if(y.p_call_traps){var d=arguments.length;if(3!==d)throw h(`TypeCzech.mutateSnapshot() needs 3 parameters, not ${d}`,"EX@108");if(A(c)){if("string"!==typeof a)throw d=`First TypeCzech.mutateSnapshot() parameter must be an un-empty string, not ${q(a)}`,h(d,"EX@110");if("string"!==typeof b)throw d=`Second TypeCzech.mutateSnapshot() parameter must be an un-empty string, not ${q(b)}`,
h(d,"EX@111");}else throw d=`TypeCzech.mutateSnapshot()'s 3rd parameter is not an array/object but instead a '${u(c)}'`,h(d,"EX@109");d=`${a}-${b}`;var e=pa.decycle(c);e=aa(e);e={func_name:a,var_name:b,collection_ref:c,pre_collect_str:e};N[d]?N[d].push(e):N[d]=[e];return""}},typeFinal:L,typeIsA:Na,typeProtos:ta}}O.type_czech=0<arguments.length?Ga(...arguments):"undefined"!==typeof O.TYPE_CZECH_COMMANDS&&0<O.TYPE_CZECH_COMMANDS.length?Ga(O.TYPE_CZECH_COMMANDS):{link:ea=>ea,isActive:ea=>!1};return O.type_czech}})(the_exports);
