'use strict';let the_exports;the_exports="undefined"===typeof exports?window:exports;if("undefined"===typeof TYPE_CZECH_current_test_number)var TYPE_CZECH_current_test_number="no test number assigned yet";
(function(T){T.TypeCzech=function(){function Ga(...X){function U(a,b){a=JSON.stringify(a);a=a.substring(1,a.length-1);console.log(`%c ${a}`,b)}function pa(a){let b="";const c=a.toString();c.startsWith("class ")&&c.includes(" constructor(")&&(b=a.name);return b}function Ha(a){let b=!1;null!==a&&"undefined"!==typeof a&&"function"===typeof Object.getPrototypeOf(a)&&"object"===typeof a.prototype&&pa(a)&&(b=!0);return b}function Ia(a){let b="";a.toString().startsWith("function ")&&(b=a.name);return b}
function Ja(a){var b=!1;null!==a&&"undefined"!==typeof a&&"object"===typeof Object.getPrototypeOf(a)&&(a=a.constructor,b=(b=pa(a))?b:Ia(a));return b}function Ka(a){let b=!1;"string"===typeof a&&qa.includes(a)&&(b=!0);return b}function ra(a){var b=!1;if(null!==a&&"undefined"!==typeof a){const c=[];function d(e){e=Object.getPrototypeOf(e);null!==e&&(c.push(e.constructor.name),d(e))}b=Object.getPrototypeOf(a).constructor.name;qa.includes(b)?b=[b]:(d(a),b=c)}return b}function sa(a){a=ra(a);let b=!1;a&&
(b=a.shift());return b}function v(a){const b=sa(a);return b?b:null===a?"null":a instanceof Date?"Date":a instanceof RegExp?"RegExp":Array.isArray(a)?"Array":typeof a}function D(a){a=v(a);return"Array"===a?!0:"Object"===a}function ta(a){let b=!1;jb.has(a)?b=!0:ua[a]&&(b=!0);return b}function M(a){return ua[a]?ua[a]:a}function Y(a){return La[a]?La[a]:a}function ja(a){return a.replace(/"/g,"'")}function x(a){if(D(a))a=Ma(a);else if("undefined"===typeof a)a="-un-defined-";else if("bigint"===typeof a)a=
`${a}n`;else if("string"===typeof a)a=a.replace(/"/g,"'");else{const b=JSON.stringify(a);a="object"===typeof a?ja(b):b}return a}function Ma(a){const b=[];if(Array.isArray(a))a.forEach(c=>{const d=x(c);"String"===v(c)?b.push(`'${d}'`):b.push(d)}),a=`[${b.join()}]`;else{for(const [c,d]of Object.entries(a))a=x(d),a="String"===v(d)?`'${c}':'${a}'`:`'${c}':${a}`,b.push(a);a=`{${b.join()}}`}return a}function Na(a,b){return"bigint"===typeof b?`${b}n`:"undefined"===typeof b?"-un-defined-":Number.isNaN(b)?
"-NaN-":"function"===typeof b||b&&b.constructor===RegExp?`${String(b).substring(0,30)} ...`:b}function I(a){a=JSON.stringify(a,Na);return x(a)}function p(a,b){return va&&b?(a=`${b} - ${a}`,wa&&U(a,"background: #ee0; color: #F00"),a):a}function Z(a){let b="";if(!Ka(a)&&"string"===typeof a){const c=a.toLowerCase();Oa[c]&&(b=p(`The type '${a}' is not a conform type, but it looks just like '${Oa[c]}'`,"TC@33"))}return b}function xa(a){if(0<Object.keys(a).length){const [b,c]=Object.entries(a)[0];a=Z(c);
a||(a=x(c),a=p(` The key '${b}', which has a type of '${a}', is missing in the checked object`,"TC@46"))}else a="";return a}function aa(a){if(a instanceof Date)var b="Invalid Date"==a;else a instanceof RegExp?b="/(?:)/"===a.toString():Number.isNaN(a)?b=!0:null==a?b=!0:(b=0===a.length,a="object"===typeof a&&0===Object.keys(a).length,b=b||a);return b}function ka(a,b){let c;1===a.length?[c]=a:c=a[b];return c}function E(a){let b;null===a||void 0===a||"undefined"===typeof a.length||"string"===typeof a?
b=a:1===a.length?[b]=a:b=[...a];return b}function J(a){let b=0;a&&(b=1===a.length||Array.isArray(a)?179:0);return b}function ya(a){function b(){return`${N} : ${P}`}function c(h){const k=[];h.forEach(q=>{const m=sa(q);m?k.push(`'${m}'`):(q=I(q),k.push(q))});return k}function d(h,k,q,m,u){var w=q.split("() ")[0];N+=1;z[w].CHECKS+=1;la&&U([N],"background: #ee0; color: #00F");if(h){P+=1;z[w].FAILURES+=1;Pa(b());k=` ${k}() ${q} `;if("string"===typeof h)k=h;else{const [t,B,K]=h;h=c(m);1<h.length?(h=`[${h}]`,
m=x(m)):(m=x(m),m=m.substring(1,m.length-1));q=I(K);k=k+B+("\n\t\t"+t);w=" EMPTY ASSERTION";if("conform(arguments, expected_types)"===t||"conformExtras(arguments, expected_types)"===t||"objectConformExtras(arguments, expected_types)"===t||"conformUnion(arguments, expected_types)"===t)w="   EXPECTED TYPE";k+=`${"\n\t\t"}${"    ACTUAL TYPES"} ${h}`;k+=`${"\n\t\t"}${"    ACTUAL VALUE"} ${m}`;k+=`${"\n\t\t"}${w} ${q}`;k+=`${"\n\t\t"}${"CALLING FUNCTION"} ${u}`;k+="\n\t\t"}if(ba)throw k;ca&&console.log(k)}}
function e(h){h=h.toString().match(kb);const k=`${h[0]})`.replace(/^function /,"");h[2].split(", ").includes("arguments")&&U(`Parameter 'arguments' shadows arguments object : ${h[0]})`,"background: #ee0; color: #00F");return k}function g(h,k,q){const m=e(q),u=q.apply(null,k);d(u,q.name,h,k,m)}function f(h,k,q,m){const u=e(m);k=m.apply(k,q);d(k,m.name,h,q,u)}function l(h){return"object"===typeof h?`{ ${Object.keys(h).map(k=>`${k}()`).reduce((k,q)=>`${k}, ${q}`)} }`:`${h.name}()`}function n(h,k,q){if("function"!==
typeof h&&"object"!==typeof h)throw h=x(h),k=`${k}, is a not a function nor an object that has a value of '${h}'`,k=p(k,`TC@${q}`),k;}function r(h,k){const q=l(k);if(void 0===h)throw p(`The function to be checked by ${q} is 'undefined', maybe namespace issue.`,"TC@05");if(h===k)throw h=`_ParametersCheck you cannot use ${h.name}() to test`+`${k.name}(), they must be different functions`,h=p(h,"TC@28"),h;}function y(h){z[h]?z[h].PRE+=1:z[h]={PRE:1,POST:0,["CHECKS"]:0,["FAILURES"]:0}}function C(h){z[h]?
z[h].POST+=1:z[h]={PRE:0,POST:1,["CHECKS"]:0,["FAILURES"]:0}}function Q(h,k,q){const m=h.name;return new Proxy(h,{apply(u,w,t){da(b());A&&k&&(y(m),"undefined"===typeof w?g(`${m}${"() "}${"PRE-FUNC:"}`,t,k):f(`${m}${"() "}${"PRE-FUNC:"}`,w,t,k));u=u.apply(w,t);A&&q&&(C(m),"undefined"===typeof w?g(`${m}${"() "}${"POST-FUNC:"}`,[u],q):f(`${m}${"() "}${"POST-FUNC:"}`,w,[u],q));return u}})}function F(h,k,q,m){const u=new Set;q&&Object.keys(q).forEach(t=>u.add(t));m&&Object.keys(m).forEach(t=>u.add(t));
let w=!1;Object.isFrozen(k)&&(w=!0,k=Object.assign({},k));u.forEach(t=>{if(t!==h){let B=!1;q&&(B=q[t]||!1);let K=!1;m&&(K=m[t]||!1);k[t]&&(k[t]=Q(k[t],B,K))}});w&&Object.freeze(k);return k}function ma(h,k){return"function"===typeof h?h:"undefined"===typeof h?!1:h[k]}function lb(h,k,q){const m=h.name,u=ma(k,m),w=ma(q,m);return new Proxy(h,{apply(){},construct(t,B,K){da(b());A&&u&&(y(m),g(`${m}${"() "}${"PRE-CLASS:"}`,B,u));t=Reflect.construct(t,B,K);t=F(m,t,k,q);A&&w&&(C(m),f(`${m}${"() "}${"POST-CLASS:"}`,
t,[t],w));return t}})}function mb(h,k,q){const m=h.name,u=ma(k,m),w=ma(q,m);return new Proxy(h,{apply(t,B,K){da(b());A&&u&&(y(m),g(`${m}${"() "}${"PRE-OBJ:"}`,K,u));t=t.apply(B,K);t=F(m,t,k,q);A&&w&&(C(m),g(`${m}${"() "}${"PRE-OBJ:"}`,[t],q[m]));return t},construct(t,B){da(b());A&&u&&(y(m),g(`${m}${"() "}${"POST-OBJ:"}`,B,u));t=new t(...B);t=F(m,t,k,q);A&&w&&(C(m),f(`${m}${"() "}${"POST-OBJ:"}`,t,[t],w));return t}})}function nb(h,k,q){var m=arguments.length;if(2!==m&&3!==m)throw p(`TypeCzech.confirmParameters() needs 2 or 3 parameters, not ${m}`,
"TC@52");if(Qa.has(h)){var u=`${h.name}() is already proxied with ${h.name}`;u=p(u,"TC@04");throw u;}if("function"!==typeof h)throw u=`The first parameter to TypeCzech.check(), target_proxy is not a function, but is instead ${x(h)}`,u=p(u,"TC@06"),u;if(k)for(var w in k)m=k[w],r(h,m),n(m,"TypeCzech.check() 2nd parameter, PRE-CHECK()",31);if(q)for(u in q)w=q[u],r(h,w),n(w,"TypeCzech.check() 3rd parameter, POST-CHECK()",37);Ha(h)?u=lb(h,k,q):(u=v(k),w=v(q),u="Object"===u||"Object"===w?mb(h,k,q):Q(h,
k,q));Qa.add(u);return u}var V=arguments.length;if(1<V)throw p(`TypeCzech.confirmParameters() needs 0 or 1 parameters, not ${V}`,"TC@53");let da=()=>"",Pa=()=>"",z=[],N=0,P=0,A=!1;V=(h,k,q)=>h;V=za?nb:V;if(za){a&&"Object"!==v(a)&&U(["_ParametersCheck - arg_check_events is not an Object with onStart(), onCheck(), onError() ",a],"background: #ee0; color: #F00");"undefined"!==typeof window&&U(["TypeCzech-init","ver 4.0",ba?"THROW-EXCEPTIONS":"",ca?"LOG-ERRORS":"",L?"UNDEF-OK":"",la?"CONSOLE-COUNT":"",
a],"background: #cc0; color: #080");if(void 0!==a.onStart)a.onStart("Start");void 0!==a.onCheck&&(da=a.onCheck);void 0!==a.onError&&(Pa=a.onError);A=!0}return{confirmParameters:V,checkBegin_:function(){A=!0;P=N=0},checkTally_:function(){return N},checkEnd_:function(){A=!1},failureTally_:function(){return P},failureRatio_:function(){return`${P}/${N}`},stats_:function(h){"undefined"===typeof h?(h=z,h[0]=`Total Checks : ${N}`,h[1]=`Failure Count: ${P}`):h={possible_type:z[h]};return h},statsReset_:function(){z=
[];P=N=0;A=A=!1}}}function ea(a,b){b||(b={});"function"===typeof b&&(b={cmp:b});var c="boolean"===typeof b.cycles?b.cycles:!1,d=b.cmp&&function(g){return function(f){return function(l,n){return g({key:l,value:f[l]},{key:n,value:f[n]})}}}(b.cmp),e=[];return function l(f){f&&f.toJSON&&"function"===typeof f.toJSON&&(f=f.toJSON());if(void 0!==f){if("number"==typeof f)return isFinite(f)?""+f:"null";if("object"!==typeof f)return JSON.stringify(f);var n;if(Array.isArray(f)){var r="[";for(n=0;n<f.length;n++)n&&
(r+=","),r+=l(f[n])||"null";return r+"]"}if(null===f)return"null";if(-1!==e.indexOf(f)){if(c)return JSON.stringify("__cycle__");throw new TypeError("Converting circular structure to JSON");}var y=e.push(f)-1,C=Object.keys(f).sort(d&&d(f));r="";for(n=0;n<C.length;n++){var Q=C[n],F=l(f[Q]);F&&(r&&(r+=","),r+=JSON.stringify(Q)+":"+F)}e.splice(y,1);return"{"+r+"}"}}(a)}function Ra(a,b){a=Object.entries(a);const [c,d]=a[0];b=x(b);return p(`Element '${c}' is supposed to be a '${d}', but is missing : ${b}`,
"TC@03")}function na(a,b,c,d){let e="";const g=v(a),f=v(b);void 0===b?e="":g!==f?g!==b&&(a=I(a),e=p(`Parameter is meant to be '${f}' but is`+` of the wrong type of '${g}':${a}`,"TC@36")):"Array"===f?e=Sa(a,b,c,d):"Object"===f&&(e=Ta(a,b,c,d));return e}function Ua(a){let b="";a=a.toLowerCase();ob.includes(a)||(b=" VALID TYPES = A:Array, I:BigInt, B:Boolean, D:Date, F:Function, N:Number, O:Object, R:RegExp, S:String, Y:Symbol");return b}function Sa(a,b,c,d){let e="";if(1===b.length&&1<a.length)e=0===
d?"Use type_czech.conform( [...arguments], ['the-var-type']) for VARIADIC function parameters":Va(a,b[0],c,d+1);else{const g=Array.from(b);b=g.length;a.forEach((f,l)=>{if(""===e){const n=v(f),r=ka(g,l);D(r)?e=na(f,r,c,d+1):(f=M(ka(g,l)),f===n||"TYPE-EXTRAS"===c&&void 0===f||L&&"null"===n||L&&"undefined"===n||(e=Wa(f,l,n)));delete g[l]}});1!==b&&a.length<b&&(e=Ra(g,a))}return e}function Ta(a,b,c,d){const e=[],g={...b};Object.entries(a).forEach(l=>{let n="";const [r,y]=l;D(y)?(n+=na(a[r],b[r],c,d),
delete g[r]):Object.prototype.hasOwnProperty.call(g,r)?(n+=Xa(g,r,y),delete g[r]):"TYPE-VERIFY"===c&&(n=p(`Extra key in checked object - (${r}:'${y}')`,"TC@39"));n&&e.push(n)});let f="";0<e.length&&e.forEach(l=>{f+=l});return f+=xa(g)}function Ya(a,b){b=M(b);var c="";"null"===b||"undefined"===b?c=p(`The type '${b}' is not a conform type`,"TC@17"):ta(b)?(c=v(a),c=c===b?"":"Array"===c?`The variable '[]', which is a 'Array', is not a '${b}'`:"Object"===c?`The variable '{}', which is a 'Object', is not a '${b}'`:
"undefined"===c?p(`The variable '${void 0}', is not a '${b}'`,"TC@34"):`The variable '${a}', which is a '${c}', is not a '${b}'`):Ja(a)!==b&&((a=Z(b))||(a=p(`The type '${b}' is not the correct class`,"TC@16")),c=a);return c}function Aa(a,b,c,d){return D(b)?na(a,b,c,d):Ya(a,b)}function fa(a,b,c,d){Array.isArray(a)||(d=179);return Aa(a,b,c,d)}function Za(a,b){a=Object.entries(a);const [c,d]=a[0];b=I(b);return p(`ELEMENT '${c}' is promised to be a '${d}', but is missing : ${b}`,"TC@29")}function $a(a,
b,c,d,e,g,f){e=I(d);return"EMPTY-ERROR"===a||"EM-ER"===a?aa(b)?p(`ELEMENT '${c}' is erroneously empty :`,"TC@30"):"":"EMPTY-OK"===a||"EM-OK"===a||"EMPTY-IGNORE"===a||"EM-IG"===a?O(d[c],a,g,f):"String"===v(a)?p(`ELEMENT '${c}' is incorrect  type, '${a}', only`+` [EM-ER, EMPTY-ERROR, EMPTY-OK, EM-OK, EMPTY-IGNORE, EM-IG] allowed  : ${e}`,"TC@32"):O(d[c],a,g,f)}function pb(a,b,c,d){b=x(JSON.stringify(b));return p(`The parameter array ${a} does not have the same number of elements as ${b}. `+` Lengths are different ${c} !== ${d}.`,
"TC@20")}function O(a,b,c,d){const e=v(b);void 0===b?a="":"Array"===e?("Array"===v(b[0])&&(1===b.length&&Ba(a,b[0],c,d),Ba(a,b,c,d)),a=ab(a,b,c,d)):a="Object"===e?bb(a,b,c,d):Ca(a,b);return a}function Ca(a,b){let c="";b=Y(b);const d=v(a);if("EMPTY-ERROR"===b){const e=v(a);Da(e)?aa(a)&&("Object"===d&&(a=" { } "),c=p(`${b} states '${d}' must not `+`be empty for the value '${a}'`,"TC@24")):c=p(`A '${d}' cannot be empty, so the state`+` of '${b}' is illegal for the value '${a}'`,"TC@25")}else"EMPTY-OK"!==
b&&"EMPTY-IGNORE"!==b&&(c=p(`Must 'EMPTY-OK' or 'EMPTY-ERROR' not '${b}'`,"TC@11"));return c}function cb(a,b,c,d){return D(b)?O(a,b,c,d):Ca(a,b)}function ha(a,b,c,d){return 1!==b.length||"EMPTY-OK"!==b[0]&&"EM-OK"!==b[0]?cb(a,b,c,d):p("Completely pointless as checking with ['EM-OK'] or ['EMPTY-OK'] matches everything","TC@12")}function db(a,b,c){const [d,e]=a;let g=a="",f=!1;e.forEach(l=>{let n=l;"String"===l&&1===d.length&&(n=[l]);l=ha(d,n,b,c);""===l?f=!0:g=l});f||(a=g);return a}function eb(a,b,
c){const [d,e]=a;let g=a="",f=!1;e.forEach(l=>{let n=l;"String"===l&&1===d.length&&(n=[l]);l=fa(d,n,b,c);""===l?f=!0:g=l});f||(a=g);return a}function fb(a){let b=a;a=a[0];Array.isArray(a)&&(b=a);b.forEach(c=>{if("object"===typeof c)Ea=c;else if("UNDEF-OK"===c)L="UNDEF-OK";else if("DEBUG-CONSOLE-TRACE"===c)wa="DEBUG-CONSOLE-TRACE";else if("THROW-EXCEPTIONS"===c)ba="THROW-EXCEPTIONS";else if("LOG-ERRORS"===c)ca="LOG-ERRORS";else if("CONSOLE-COUNT"===c)la="CONSOLE-COUNT";else if("NO-CHECKING"!==c)if("DEBUG-ERROR-TAGS"===
c)va="DEBUG-ERROR-TAGS";else if(""!==c)throw c=`Not THROW-EXCEPTIONS/LOG-ERRORS/UNDEF-OK/DEBUG-CONSOLE-TRACE/NO-CHECKING, unknown : ${I(c)}`,c=p(c,"TC@21"),c;});gb=za=!(!ba&&!ca);return[ba,ca,L,wa,la,va]}function G(a,b,c){c=x(c);return[a,b,c]}function R(a,b,c){var d="";if(2!==a.length)d=p(`TypeCzech.${b}() has 2 ${"arguments"} not ${a.length}`,"TC@14");else{const [g,f]=a;var e=v(g);const l=v(f),n=JSON.stringify(e);a=f;"string"!==typeof f&&(a=JSON.stringify(f));"Array"===e&&"Array"!==l?(b=1<g.length,
"Array"!==f&&"A"!==f&&b&&(d=g,b=M(a),d=p("Comparing actual [] parameter, with a"+` value of ['${d}'], against the expected shape of ${b}. They should be the same type.`+` You cannot compare an array with a non-array; both []s, or both ${b}s.`,"TC@58"),a=ja(a),d=G(c,d,a))):"Array"===l&&"Array"!==e?(d=e,e=a,b=x(g),e=M(e),d=p(`Comparing actual '${d}' parameter,`+` with a value of "${b}", in relation to the expected shape of ${e}. They should be the`+` same type. You cannot compare an array with a non-array; both []s, or both '${d}'s. Or same object keys.`,
"TC@49"),a=ja(a),d=G(c,d,a)):"Array"!==l&&("Object"===l?"Object"!==e&&(d=p(`TypeCzech.${b}() called with '{}' against '!{}'.`+` Contrasting '${n}' with '${a}'.`,"TC@07")):"String"!==l&&(d=p(`TypeCzech.${b}() called with 'a-variable' and 'not-a-variable type'.`+` Matching '${n}' with '${a}'.`+` Preferably try TypeCzech.${b}(12, 'Number')`,"TC@50")))}return d}function Fa(a,b){var c="";if(2!==a.length)c=p(`TypeCzech.${b}() needs 2 parameters, not ${a.length}`,"TC@51");else{a=a[1];const d=JSON.stringify(a);
"Array"!==v(a)?c=p(`TypeCzech.${b}() called with a second parameter`+` as a non-array shape of ${d}`,"TC@15"):2>a.length&&(c=x(a),c=p(`TypeCzech.${b}()  needs at least 2 choices for a union, not ${a.length} of ${c}`,"TC@50"))}return c}function W(a){if(160>a.length)var b=a;else b=a.substring(0,100),a=a.substring(a.length-50),b=`${b} ${"<<<<<<...>>>>>>"} ${a}`;return b}function hb(a,b){var c="";if(a!==b){c=0;for(var d=!1;a[c]===b[c];){if(c===a.length||c===b.length){d=!0;break}c+=1}const [g,f]=[c,d];
var e=a.length;d=b.length;f?e>d?(c=0===d?"``":b,e=a.substring(g),b="``"):(c=0===e?"``":a,e="``",b=a.substring(g)):(c=0===g?"``":a.substring(0,g),e=0===e?"``":a.substring(g),b=0===d?"``":b.substring(g));a=e;c=W(c);a=W(a);b=W(b);c=x(`${"\n\t\t"}START-SAME ~ ${c}`);a=x(`${"\n\t\t"}  PRE-DIFF ~ ${a}`);b=x(`${"\n\t\t"} POST-DIFF ~ ${b}`);c=`${c}${a}${b}`}return c}let gb=!0,H,Ea=!1,za=!1;const S={},Qa=new WeakSet;let ba=!1,ca=!1,L=!1,la=!1,va=!1,wa=!1;const kb=/([^(]*\()([^)]*)/,La={"EM-OK":"EMPTY-OK",
"EM-ER":"EMPTY-ERROR","EM-IG":"EMPTY-IGNORE"},qa="Array BigInt Boolean Date Function Number Object RegExp String Symbol".split(" "),Oa={array:"Array",bigint:"BigInt",boolean:"Boolean",date:"Date",function:"Function",number:"Number",object:"Object",regexp:"RegExp",string:"String",symbol:"Symbol"},jb=new Set(qa),ua={A:"Array",I:"BigInt",B:"Boolean",D:"Date",F:"Function",N:"Number",O:"Object",R:"RegExp",S:"String",Y:"Symbol"},ob="a array i bigint b boolean d date f function n number o object r regexp s string y symbol".split(" "),
oa={backBlink:a=>{document.body.style.background=a;setTimeout(()=>{document.body.style.background="white"},100)},onStart:()=>oa.backBlink("green"),onCheck:()=>oa.backBlink("blue"),onError:()=>oa.backBlink("red")},Da=a=>"Array"===a?!0:"Object"===a?!0:"String"===a?!0:"RegExp"===a?!0:"Date"===a?!0:"Number"===a,ia={decycle:function(a,b){var c=new WeakMap;return function f(e,g){void 0!==b&&(e=b(e));if(!("object"!==typeof e||null===e||e instanceof Boolean||e instanceof Date||e instanceof Number||e instanceof
RegExp||e instanceof String)){var l=c.get(e);if(void 0!==l)return{$ref:l};c.set(e,g);if(Array.isArray(e)){var n=[];e.forEach(function(r,y){n[y]=f(r,g+"["+y+"]")})}else n={},Object.keys(e).forEach(function(r){n[r]=f(e[r],g+"["+JSON.stringify(r)+"]")});return n}return e}(a,"$")},retrocycle:function(a){var b=/^\$(?:\[(?:\d+|"(?:[^\\"\u0000-\u001f]|\\(?:[\\"\/bfnrt]|u[0-9a-zA-Z]{4}))*")\])*$/;(function e(d){d&&"object"===typeof d&&(Array.isArray(d)?d.forEach(function(g,f){if("object"===typeof g&&null!==
g){var l=g.$ref;"string"===typeof l&&b.test(l)?d[f]=eval(l):e(g)}}):Object.keys(d).forEach(function(g){var f=d[g];if("object"===typeof f&&null!==f){var l=f.$ref;"string"===typeof l&&b.test(l)?d[g]=eval(l):e(f)}}))})(a);return a}},Va=(a,b,c,d)=>{let e="";const g=M(b);a.forEach((f,l)=>{if(""===e){const n=v(f);if(D(g))e=Aa(f,g,c,d);else if(!(g===n||L&&"null"===n||L&&"undefined"===n)){let r=Z(g);r||(f=x(f),r=p(`ELEMENT '${l}' is asserted to be a '${g}',`+` but is fallaciously a '${n}' : ${f}`,"TC@45"));
e=r}}});return e},Wa=(a,b,c)=>{let d="",e;null===a?e="null":"undefined"===typeof a?e="undefined":(e=a,d=Ua(a));(a=Z(e))||(a=p(` ELEMENT '${b}' is assumed to be a '${e}',`+` but is mistakenly a '${c}'.${d}`,"TC@44"));return a},Xa=(a,b,c)=>{let d="";a=M(a[b]);if(ta(a)){const e=v(c);a===e||L&&"null"===e||L&&"undefined"===e||("undefined"===typeof c?d=p(`Key '${b}' was given to be a '${a}' but was instead 'undefined'`,"TC@41"):"null"===e?d=p(`Key '${b}' was determined to be a '${a}' but was instead 'null'`,
"TC@42"):(c=x(c),d=p(`Property '${b}' is indicated to be a '${a}',`+` but is inaccurately a '${e}' : ${c}`,"TC@43")))}else(d=Z(a))||(d=p(`The type '${a}' is not conform`,"TC@40"));return d},Ba=(a,b,c,d)=>{let e="";const g=v(a);if("Array"!==g){const f=x(a);e=p(`Variable '${a}' must be an array but is instead a '${g}', : ${f}`,"TC@97")}else a.forEach((f,l)=>{""===e&&(1===b.length?((f=O(f,b,c,d))&&(f+=` inside [${l}]`),e+=f):e+=O(f,b[l],c,d))});return e},ab=(a,b,c,d)=>{let e="";var g=a.length;const f=
b.length,l=x(JSON.stringify(a));if(0===g)e=p(`The parameter array ${l} is empty.`,"TC@19");else if("EMPTY-EXTRAS"!==c&&1<f&&f!==g)e=pb(l,b,g,f);else{const n=Array.from(b),r=n.length;g=v(a);"Array"!==g?e=p(`Variable '${a}' must be an array but is a '${g}', : ${l}`,"TC@96"):a.forEach((y,C)=>{if(""===e){const Q=v(y),F=ka(n,C);D(F)?e=O(a[C],F,c,d):1!==r&&delete n[C];(y=$a(F,y,C,a,Q,c,d))&&(e=y)}});1!==r&&"EMPTY-EXTRAS"!==c&&a.length!==r&&(e=Za(b,a))}return e},ib=(a,b,c)=>{let d="";a=Y(a);if("EMPTY-ERROR"===
a){const e=v(b);Da(e)?aa(b)&&(b=I(b),d=p(`'${c}' is a '${e}' which is reputed `+`to be '${a}' but has a value of ${b}.`,"TC@08")):d=p(`Cannot be inconform '${c}' ${a}' is a ${b} :: ${e}`,"TC@09")}else"EMPTY-OK"!==a&&"EMPTY-IGNORE"!==a&&(c=`bad inconform key '${x(a)}', must be either EMPTY-OK -ER -IG`,d=p(c,"TC@10"));return d},bb=(a,b,c,d)=>{const e=[],g={...b};Object.entries(a).forEach(l=>{var n="";const [r,y]=l;l=Y(g[r]);D(y)?(l=Y(b[r]),aa(y)&&"EMPTY-ERROR"===l?(n=I(y),n=p(`Key '${r}' was understood to be '${l}' but was rather '${n}'`,
"TC@26")):n+=O(a[r],l,c,d),delete g[r]):Object.prototype.hasOwnProperty.call(g,r)?(n=ib(l,y,r),delete g[r]):"EMPTY-VERIFY"===c&&(n=p(`Extra key in checked object - (${r}:'${y}')`,"TC@27"));n&&e.push(n)});let f="";0<e.length&&e.forEach(l=>{f+=l});return f+=xa(g)};fb(X);H=Ea?ya(Ea):ya(!1);return{_ParametersCheck:ya,_arrayOfOneType:Va,_arrayRecurseLevel:J,_aTypeOf:v,_canBeEmpty:Da,_className:pa,_collectionToStr:Ma,_coloredConsole:U,_consoleError:p,_cycle:ia,_doUnionEmpty:db,_doUnionShape:eb,_doubleToSingleQuotes:ja,
_emptyArrayInArray:Ba,_emptyArrayTypes:ab,_emptyCheck:ha,_emptyCollectionTypes:bb,_emptyContainer:O,_emptyError:$a,_emptyErrorMess:Za,_emptyKeysChecked:ib,_emptyScalar:Ca,_emptyVariable:cb,_fast_json_stable_stringify:ea,_functionName:Ia,_getParameters:E,_isAClass:Ha,_anObjectsType:Ja,_isBuiltInType:Ka,_isCollection:D,_isEmpty:aa,_isScalar:function(a){return!D(a)},_isPlainJsType:ta,_jsonStr:I,_missingKey:xa,_unionChecks:Fa,_refDiff:hb,_shapeArrayTypes:Sa,_shapeCheck:fa,_shapeCollectionTypes:Ta,_shapeContainer:na,
_shapeErrorMess:Ra,_shapePropertyType:Xa,_shapeScalar:Ya,_shapeVariable:Aa,_shortToLongEmpty:Y,_shortToLongType:M,_showRealTypes:Ua,_shrinkDiffs:W,_specParameters:fb,_stringifyReplacer:Na,_toStr:x,_twoArrays:R,_typeFromArray:ka,_wrongType:Wa,_NOT_VARIAD_ARR_L_179:179,_POS_VARIAD_ARR_L_0:0,TYPE_CZECH_EVENTS:oa,CZECH_ERROR_INDENT:"\n\t\t",is_active:gb,check:function(a,b,c){return"undefined"===typeof c?H.confirmParameters(a,b,!1):H.confirmParameters(a,b,c)},checkBegin:function(){return H.checkBegin_()},
checkEnd:function(){return H.checkEnd_()},checkTally:function(){return H.checkTally_()},conform:function(a,b){var c=E(a);let d=R([c,b],"conform","conform(arguments, expected_types)");""===d&&(a=J(a),d=(c=fa(c,b,"TYPE-VERIFY",a))?G("conform(arguments, expected_types)",c,b):"");return d},conformExtras:function(a,b){var c=E(a);if(2>c.length||2>b.length)throw p("TypeCzech.conformExtras() needs each array to have at least two types to work","TC@01");let d=R([c,b],"conformExtras","conformExtras(arguments, expected_types)");
if(""===d){if("Array"!==v(c)||"Array"!==v(b))throw p("TypeCzech.conformExtras() needs two arrays to work","TC@54");a=J(a);d=(c=fa(c,b,"TYPE-EXTRAS",a))?G("conformExtras(arguments, expected_types)",c,b):""}return d},conformUnion:function(a,b){var c=E(a);let d=Fa([c,b],"conformUnion");""===d&&(a=J(a),d=(c=eb([c,b],"TYPE-VERIFY",a))?G("conformUnion(arguments, expected_types)",c,b):"");return d},failureRatio:function(){return H.failureRatio_()},failureTally:function(){return H.failureTally_()},mutateSnapshot:function(a,
b,c){var d=arguments.length;if(3!==d)throw p(`TypeCzech.mutateSnapshot() needs 3 parameters, not ${d}`,"TC@55");if(!D(c))throw d=`TypeCzech.mutateSnapshot()'s 3rd parameter is not an array/object but instead a '${v(c)}'`,d=p(d,"TC@56"),d;d=`${a}-${b}`;var e=ia.decycle(c);e=ea(e);e={func_name:a,var_name:b,collection_ref:c,pre_collect_str:e};S[d]?S[d].push(e):S[d]=[e];d=ia.decycle(S);ea(d)},mutated:function(a,b){var c=`${a}-${b}`,d="";if(S[c]){c=S[c].pop();const {collection_ref:e,pre_collect_str:g}=
c;c=ia.decycle(e);c=ea(c);if(g!==c){const f=x(g);d=x(c);a=`The reference variable '${b}' in function '${a}()' changed values`;b=W(f);d=W(d);b=`${"\n\t\t"}from ${b}`;d=`${"\n\t\t"}  to ${d} ${"\n\t\t"}`;c=hb(g,c);d=p(`${a}${b}${d}${c}`,"TC@48")}}else d=p(`No record of a mutateSnapshot('${c}', a_var)`,"TC@47");c=ia.decycle(S);ea(c);return d},objectConformExtras:function(a,b){var c=E(a);if("Object"!==v(c)||"Object"!==v(b))throw p("TypeCzech.objectConformExtras() needs two Objects to work","TC@02");let d=
R([c,b],"objectConformExtras","objectConformExtras(arguments, expected_types)");""===d&&(a=J(a),d=(c=fa(c,b,"TYPE-EXTRAS",a))?G("objectConformExtras(arguments, expected_types)",c,b):"");return d},objectIsA:function(a,b){a=ra(a);let c=!1;a&&(c=a.includes(b));return c},objectInterface:function(a,b){a=E(a);let c="";for(const d in b){let e="";const g=M(b[d]);if("string"!==typeof g)e=`objectInterface() {${d}:'${g}'} has a bad type - not string`;else if("Function"!==g&&"Object"!==g)e=`objectInterface() only allows functions and objects, not {${d}:'${g}'}`;
else{const f=a[d];f||(e="missing key");const l=v(f);g!==l&&(e=`actual type of '${d}' is '${l}', with a value `+`of '${f}', not the expected '${g}' type`)}e&&!c&&(c=e)}c&&(c=`Interface mismatches : ${c}`);return c},objectPrototypes:ra,objectType:sa,objectValuelessExtras:function(a,b){var c=E(a);if("Object"!==v(c)||"Object"!==v(b))throw p("TypeCzech.objectValuelessExtras() needs two Objects to work","TC@22");let d=R([c,b],"objectValuelessExtras","objectValuelessExtras(arguments, expected_types)");""===
d&&(a=J(a),d=(c=ha(c,b,"TYPE-EXTRAS",a))?G("objectValuelessExtras(arguments, expected_types)",c,b):"");return d},stats:function(a){return H.stats_(a)},statsReset:function(){return H.statsReset_()},valueless:function(a,b){var c=E(a);let d=R([c,b],"valueless","valueless(arguments, expected_emptys)");""===d&&(a=J(a),d=(c=ha(c,b,"EMPTY-VERIFY",a))?G("valueless(arguments, expected_emptys)",c,b):"");return d},valuelessExtras:function(a,b){var c=E(a);if(2>c.length||2>b.length)throw p("TypeCzech.valuelessExtras() needs each array to have at least two types to work",
"TC@18");let d=R([c,b],"valuelessExtras","valuelessExtras(arguments, expected_emptys)");if(""===d){if("Array"!==v(c)||"Array"!==v(b))throw p("TypeCzech.valuelessExtras() needs two arrays to work","TC@37");a=J(a);d=(c=ha(c,b,"EMPTY-EXTRAS",a))?G("valuelessExtras(arguments, expected_emptys)",c,b):""}return d},valuelessUnion:function(a,b){var c=E(a);let d=Fa([c,b],"valuelessUnion");""===d&&(a=J(a),d=(c=db([c,b],"EMPTY-VERIFY",a))?G("valuelessUnion(arguments, expected_emptys)",c,b):"");return d}}}T.type_czech=
0<arguments.length?Ga(...arguments):"undefined"!==typeof T.TYPE_CZECH_COMMANDS&&0<T.TYPE_CZECH_COMMANDS.length?Ga(T.TYPE_CZECH_COMMANDS):{check:X=>X,stats:X=>X,is_active:!1};return T.type_czech}})(the_exports);
