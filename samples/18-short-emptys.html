<meta charset="utf-8" />


<link rel="stylesheet"
  href="https://fonts.googleapis.com/css?family=Inconsolata">
  
<div id='js-div' style="width:55%">
  <div id='js-code'>the javascript</div>
</div>

<div id="the-explanation" style="width:45%">
  <div class='an-explantion'>18 TypeCzech Short Empty &amp; Valueless Declarations</div>
  <div id='explanation-text'>
    <br>

    Instead of using 'EMPTY-OK' &amp; 'EMPTY-ER' you can use the short cuts.
    <ul>
   <li>'EM-OK' : 'EMPTY-OK'</li>
   <li>'EM-ER' : 'EMPTY-ER'</li>
    </ul>


  </div>
  <br>
</div>

<div id="console-log" style="width:45%">
  <div class='a-title'>Console Output</div>
  <div id='log-text'></div>
  <br>
</div>





<script id="check-code">

function checkCodeRun(){

if (typeof TypeCzech === 'function')
  type_czech = TypeCzech('LOG-ERRORS')   
else
  type_czech = { precedeCheck : do_nothing => do_nothing }

PERSON = (typeof PERSON === 'undefined') ? undefined : PERSON
SHOW = (typeof SHOW === 'undefined') ? undefined : SHOW

Person = type_czech.precedeCheck(Person, PERSON) 
show = type_czech.precedeCheck(show, SHOW) 

function PERSON(/* arguments */){ // first, last, birth, job
  expected_emptys = [ 'EM-ER', 'EM-OK', 'EM-ER', 'EM-OK' ]
  return type_czech.emptyVerify(arguments, expected_emptys)
}

function SHOW(/* arguments */){ // [name, year, job], salutation
  expected_emptys = [ [ 'EM-ER', 'EM-ER', 'EM-OK' ], 'EM-OK' ]
  return type_czech.emptyVerify(arguments, expected_emptys)
}

function Person(first, last, birth, job){
  const name = (last) ? `${first} ${last}` : first
  let year
  try { year = birth.getFullYear() } catch (e) { year = 0 }
  if (Number.isNaN(year)) year = 0
  return [name, year, job]
}

function show(person, salutation) {
  const [name, year, job] = person
  return `${salutation} ${name}, ${year} ${job}`
}

elizabeth_1 = Person('Elizabeth I', '', new Date(1533, 9, 7), 'Queen')
console.log('out A : ', show(elizabeth_1, 'Ms'))

linesConsole(2)

prince_charles = Person('Prince', 'Charles', new Date(1948,11,14), '', 'ROYAL')
console.log('out B : ', show(prince_charles, 'Mr'))

linesConsole(2)

alan_turing = Person('Alan', 'Turing', new Date(1912,6,23), 'Cryptographer')
console.log('out C : ', show(alan_turing, 'Mx'))

linesConsole(2)

space_baby = Person('2001: Space Odyssey Baby', '',  new Date(''), '')
console.log('out E : ', show(space_baby, 'Alien'))

 linesConsole(2)

athens_socrates = Person('Socrates', '', -470, '')
console.log('out F : ', show(athens_socrates, 'Mr'))



}

</script>

<script s r c="../consolelog.js">
  const type_czech_copy={REPLACE_NL_TAB_TAB:new RegExp(/\\n\\t\\t/g),MATCH_NL_TAB_TAB:new RegExp(/\n\t\t/g),CONSOLE_LOG_NEWLINE:"|"},isNaN=e=>e!=e;let log_count=0,code_count=0;const NEW_LINE_REGEX=new RegExp(/\|/,"g"),NBSP_REGEX=new RegExp(/~/,"g"),UNDEFINED_AS_STR="un-defined";function startCurlyDates(e){return e.replace(/\n/g,"").replace(/([^}]),'/,"$1,'").split("},'").join("},\n"+type_czech_copy.CONSOLE_LOG_NEWLINE+"'").replace(/(\d\d\d\d-\d\d-\d\d)\w\d\d:\d\d:\d\d.\d\d\d\w/gi,"$1")}function printObj(e){return startCurlyDates(type_czech._jsonStr(e).replace(/},/g,"},\n")).replace(/^{/,"{|\n").replace(/}$/,"\n|}")}function captureConsole(e){const n=console.log,t=document.getElementById(e);function o(e,n){return void 0===n?UNDEFINED_AS_STR:n}function i(e){return function(e){if(void 0===e)return UNDEFINED_AS_STR;if("string"==typeof e)return e.replace(/"/g,"'");const n=JSON.stringify(e);return"object"!=typeof e?n:function(e){return e.replace(/{"/g,"{'").replace(/":/g,"':").replace(/","/g,"','").replace(/,"/g,",'").replace(/\["/g,"['").replace(/"]/g,"']").replace(/],"/g,"],'")}(n)}(JSON.stringify(e,o))}function c(e){let n;if("object"==typeof e)n=i(e);else if("string"==typeof e){const t=e.split("");let o="";for(const e of t)log_count+=1,single_section=`<span id='log-${log_count}' class='html-section'>${e}</span>`,o+=single_section;n=o.replace(NEW_LINE_REGEX,"<br>").replace(NBSP_REGEX,"&nbsp;")}else n=i(e);t.innerHTML+=n}function r(e){json_quotes=JSON.stringify(e[0],function(e,n){if(void 0===n)return"un-defined";if(Number.isNaN(n))return"-NaN-";if("function"==typeof n||n&&n.constructor===RegExp)return`${String(n).substring(0,30)} ...`;return n},2),'"'===json_quotes[0]?json_str=json_quotes.slice(1,-1):json_str=json_quotes;const n=json_str.replace(/\\"/g,'"'),o=type_czech_copy.CONSOLE_LOG_NEWLINE+"~~~~~~~~",i=n.replace(type_czech_copy.REPLACE_NL_TAB_TAB,o).replace(/(\d\d\d\d-\d\d-\d\d)\w\d\d:\d\d:\d\d.\d\d\d\w/gi,"$1").split("");let c="";for(const e of i)log_count+=1,single_section=`<span id='log-${log_count}' class='html-section'>${e}</span>`,c+=single_section;const r=c.replace(NEW_LINE_REGEX,"<br>").replace(NBSP_REGEX,"&nbsp;");t.innerHTML+=`${r} <br>`}console.log=function(...e){let o;!function(e){const t=Array.from(e);"string"==typeof t[0]&&(t[0]=t[0].replace(/<br>/gi,""),t[0]=t[0].replace(/\|/gi,""),t[0]=t[0].replace(/&nbsp;/gi," "),t[0]=t[0].replace(/~/gi," ")),"string"==typeof t[1]&&(t[1]=t[1].replace(/<br>/gi,""),t[1]=t[1].replace(/\|/gi,""),t[1]=t[1].replace(/&nbsp;/gi," "),t[1]=t[1].replace(/~/gi," ")),n(...t)}(e);const i=e[0],s=e[1];if("a-function"===(o="function"==typeof i?"a-function":"string"==typeof i&&i.match(/OUT/)?"string-string":"string"==typeof i&&i.match(type_czech_copy.MATCH_NL_TAB_TAB)?"multi-line":"string"==typeof i&&i.startsWith("%c")?"color-line":"string"==typeof i&&"object"==typeof s?"string-object":"object"==typeof e[0]?"one-object":"default-log"))a_function=e[0],func_str=a_function.toString(),func_nl=func_str.replace(/;/g,"<br>&nbsp;&nbsp;"),t.innerHTML+=func_nl;else if("string-string"===o)c(e[0]),c(e[1]);else if("multi-line"===o)r(e);else if("color-line"===o)!function(e){if(!e[0].includes("ArgumentCheck-init")){const[n,o]=e[0].split(" "),i=parseInt(o,10);if(!isNaN(i)){const n=`<span style='${e[1]}'>${i}</span><br>`;t.innerHTML+=n}}}(e);else if("one-object"===o)r(e);else if("string-object"===o){c(e.shift()),r(e)}else if(c(e[0]),void 0!==e[1]){c(JSON.stringify(e[1]))}}}function linesConsole(e){const n=document.getElementById("log-text");for(let t=0;t!==e;t+=1)n.innerHTML+="<br>"}function jsToDiv(e,n){const t=document.scripts[n].firstChild.textContent.replace(/\n\s*linesConsole\([^)]*\)\n/g,"\n").replace(/\}\s+$/,"").replace(/^[^{]*\{/,"").split("");let o="";for(const e of t)single_section=`<span id='code-${code_count+=1}' class='html-section'>${e}</span>`,o+=single_section;document.getElementById(e).innerHTML=o}function fromToBackGround(e,n,t,o){if(n<e)throw new Error(`fromToBackGround() bad start/end : ${e} / ${n}`);for(i=e;i<=n;i+=1){const e=`${t}-${i}`,n=`back-${o}`,c=document.getElementById(e);c&&c.classList.add(n)}}function fromToBoldText(e,n,t,o){if(n<e)throw new Error(`fromToBoldText() bad start/end : ${e} / ${n}`);for(i=e;i<=n;i+=1){const e=`${t}-${i}`,n=`text-${o}`,c=document.getElementById(e);c&&c.classList.add(n)}}function fromToUnderline(e,n,t,o){if(n<e)throw new Error(`fromToUnderline() bad start/end : ${e} / ${n}`);for(i=e;i<=n;i+=1){const e=`${t} - ${i}`,n=`under-${o}`,c=document.getElementById(e);c&&c.classList.add(n)}}function fromToItalic(e,n,t){if(n<e)throw new Error(`fromToItalic() bad start/end : ${e} / ${n}`);for(i=e;i<=n;i+=1){const e=`${t} - ${i}`,n="italic-out",o=document.getElementById(e);o&&o.classList.add(n)}}
  </script>



<link r e l="stylesheet" h r e f="../arg-check.css">
<style>
.a-title{	font-family:arial; 
			text-align:right;
			font-weight: bold;
			margin-right: 20px; }
.an-explantion{
	font-family:arial; 
			text-align:center;
			font-weight: bold;
				 background-color: #dddddd; 
			margin-right: 20px;
}
#console-log{	float:right; 
			 background-color: #eeeeee; 
	width:40%; }
#js-div{	float:left;  
}
#js-fiddles{	float:left;  
	 background-color: #dddddd; 
}
#js-code{ 	white-space: pre; 
	font-family: 'Inconsolata', monospace;  
	tab-size: 4;
	-moz-tab-size: 4;
	margin-left: 8px;
	 margin-top: -32px; 
	overflow-x:auto;
}
#js-files{padding-left: 8px;}
#log-text{padding-left: 8px;}
#the-explanation{	float:right; 
	background-color: #dddddd; 	
}
#explanation-text{padding-left: 8px;}
ul{padding-left: 16px; margin-top:0px;}
li{padding-top:6px;} 
.html-section{}

.text-1{ color:red; font-weight: bold; }
.text-2{ color: red; 	font-weight: bold; }
.text-3{color: red; 	font-weight: bold; }
.text-4{ color: red;	font-weight: bolder; }
.text-5{ color: red; font-weight: bolder; }
.text-6{ color: red;	font-weight: bolder; }

.back-1{ background-color: rgb(255, 230, 230); }
.back-2{ background-color: rgb(230, 255, 230); }
.back-3{ background-color: rgb(230, 230, 255); }
.back-4{ background-color: rgb(255, 255, 160); }
.back-5{ background-color: rgb(255, 220, 255); }
.back-6{ background-color: rgb(200, 255,  255); }

.under-1{ text-decoration: underline red 1px; }
.under-2{   text-decoration:   underline green 1px;}   
.under-3{ text-decoration: underline blue 1px; }
.under-4{ text-decoration: underline black 2px; }
.under-5{ text-decoration: underline; text-decoration-color: red; }
.under-6{ text-decoration: underline; text-decoration-color: red; }
.italic-out{ font-style:italic;}
pre{
	background-color: #eee; 
	margin-left:10px;
	margin-right:10px;
}
</style>

<script s r c="../TypeCzech.js">
  function TypeCzech(...e){let t=!1,n=!1,r=!1,o=!1;const s="background: #ee0; color: #00F",i="background: #ee0; color: #F00",a="background: #cc0; color: #080";let c=!1,f=!1,y=!1;const p="TypeCzech";let l;const u="\n\t\t",E=new RegExp(/\\n\\t\\t/g),h=new RegExp(/\n\t\t/g),T=30,m="/(?:)/",O="EMPTY-OK",C="EMPTY-ER",g={"EM-OK":O,"EM-ER":C},_="TYPE-EXTRAS",d="TYPE-VERIFY",$="EMPTY-EXTRAS",b="EMPTY-VERIFY";let S=!1;const R=new Set(["symbol","date","function","number","string","boolean","array","object","regexp"]);let N=R;const k={y:"symbol",d:"date",f:"function",n:"number",s:"string",b:"boolean",r:"regexp"},A="-un-defined-",I="-NaN-",x="ArgumentCheck-init",w={backBlink:e=>{document.body.style.background=e,setTimeout(()=>{document.body.style.background="white"},100)},onStart:()=>w.backBlink("green"),onCheck:()=>w.backBlink("blue"),onError:()=>w.backBlink("red")};function X(e){return!!N.has(e)||!!k[e]}function j(e){return k[e]?k[e]:e}function M(e){return g[e]?g[e]:e}function P(e){if(void 0===e)return A;if("string"==typeof e){return e.replace(/"/g,"'")}const t=JSON.stringify(e);return"object"!=typeof e?t:function(e){return e.replace(/{"/g,"{'").replace(/":/g,"':").replace(/","/g,"','").replace(/,"/g,",'").replace(/\["/g,"['").replace(/"]/g,"']").replace(/],"/g,"],'")}(t)}function v(e,t){if(void 0===t)return A;if(Number.isNaN(t))return I;if("function"==typeof t||t&&t.constructor===RegExp){return`${String(t).substring(0,T)} ...`}return t}function K(e){return P(JSON.stringify(e,v))}function V(e){return null===e?"null":e instanceof Date?"date":e instanceof RegExp?"regexp":Array.isArray(e)?"array":typeof e}function L(e){const t=!Array.isArray(e),n="object"==typeof e,r="number"==typeof e.length;if(t&&n&&r){if("0,1,length,callee"===Object.getOwnPropertyNames(e).join())return!0}return!1}function Y(e){const t=V(e);return"array"===t||"object"===t}function z(e,t){const n=JSON.stringify(e),r=n.substring(1,n.length-1);console.log(`%c ${r}`,t)}function D(...e){f&&z(e,s)}function B(e,t){if(c&&t){const n=`${t} - ${e}`;return f&&z(n,i),n}return e}function G(e){if(Object.keys(e).length>0){const[t,n]=Object.entries(e)[0];let r=`The key '${t}', which has a type of '${n}', is missing in the checked_object`;return r=B(r,"SC@46")}return""}function U(e){if(e instanceof Date)return"Invalid Date"==e;if(e instanceof RegExp){return e.toString()===m}if(Number.isNaN(e))return!0;if(null==e)return!0;const t=0===e.length,n="object"==typeof e&&0===Object.keys(e).length;return t||n}const H=e=>"array"===e||("object"===e||("string"===e||("regexp"===e||("date"===e||"number"===e))));function F(e,t){let n;return 1===e.length?[n]=e:n=e[t],n}function J(e){if(arguments.length>1){let e=`TypeCzech.checkArgs() needs 0 or 1 arguments, not ${arguments.length}`;throw e=B(e,"SC@53")}let c=()=>"",f=()=>"",y=0,l=0,E=!1,h=!1;function T(e,r,i,a){y+=1,o&&z([y],s);const c=a.apply(r,i);if(c){l+=1,f();let r=`${p} - ${e}() - `;if("string"==typeof c)r=c;else{const[e,t,n]=c,o=K(i).slice(1,-1),s=K(n);r+=t,r+=u+e,r+=`${u} ACTUAL VALUE ${o}`,r+=`${u}EXPECTED TYPE ${s}`}if(t)throw r;n&&console.log(r)}}function m(e,t){if(function(e,t){let n;if(void 0===e){let e="ArgumentCheck The 'checked_function' must be in the exact same scope as checked_function="+`ArgumentCheck(checked_function) and ${t.name}() to be available for overriding`;throw e=B(e,"SC@05")}if(void 0!==e.is_ArgumentCheck_Proxy){if("object"==typeof t){const e=e=>`${e}()`,r=(e,t)=>`${e}, ${t}`;n=`{ ${Object.keys(t).map(e).reduce(r)} }`}else n=`${t.name}()`;let r=`ArgumentCheck ${e.name}() is already proxied with ${n}`;throw r=B(r,"SC@04")}}(e,t),"function"!=typeof e||"function"!=typeof t&&"object"!=typeof t){let n=`ArgumentCheck both '${K(e)}' and '${K(t)}' must be functions`;throw n=B(n,"SC@38")}if(e===t){let n=`ArgumentCheck you cannot use ${e.name}() to test`+`${t.name}(), they must be different functions`;throw n=B(n,"SC@28")}try{e.is_ArgumentCheck_Proxy=Symbol("is_ArgumentCheck_Proxy")}catch(e){throw B(P(e.message),"SC@47")}return function(e,t){let n;n="object"==typeof t?t[e.name]:t;if("function"!=typeof e){let t=`TypeCzech.checkArgs target_proxy is not a function ${P(e)}`;throw t=B(t,"SC@06")}return void 0===n?()=>"":n}(e,t)}function O(e,t,n){if("object"==typeof n)for(const r in n)if(r!==e){const e=n[r];t[r]=C(t[r],e)}return t}const C=S?function(e,r){if(D("realCheckArgs ENTER",e,r),function(e){if(2!==e){let t=`TypeCzech.checkArgs() needs 2 arguments, not ${e}`;throw t=B(t,"SC@52")}}(arguments.length),void 0===r)return e;const o=m(e,r),s="object"==typeof r,i=e.name;return new Proxy(e,{apply(e,a,f){c(),E&&T(i,a,f,o);const y=e.apply(a,f);return s?O(i,y,r):(function(e,r){const o=V(e);if(h.has(r)){const s=h.get(r);if(s!==o){const i=K(e),a=`The function '${r}' is improperly returning a`+` result type of '${o}', ${u}`+`Instead of the expected type of '${s}'. ${u}`+`${i}`;if(t)throw a;n&&console.log(a)}}}(y,i),y)},construct(e,t){c(),E&&T(i,void 0,t,o);const n=new e(...t);return O(i,n,r)}})}:e=>e;return S&&(h=new Map,e&&"object"!==V(e)&&z(["ArgumentCheck - arg_check_events is not an object with onStart(), onCheck(), onError() ",e],i),z([x,t?"THROW-EXCEPTIONS":"",n?"LOG-ERRORS":"",r?"UNDEF-OK":"",o?"CONSOLE-COUNT":"",e],a),void 0!==e.onStart&&e.onStart(),void 0!==e.onCheck&&(c=e.onCheck),void 0!==e.onError&&(f=e.onError),E=!0),{checkArgs:C,return_types_:h,checkCount_:function(){return y},beginChecks_:function(){E=!0,y=0,l=0},endChecks_:function(){E=!1},errorCount_:function(){return l},errorRatio_:function(){return`${l}/${y}`}}}function W(e,t){D("_shapeErrorMess ENTER",e,t);const n=Object.entries(e),[r,o]=n[0],s=B(`Index '${r}' is supposed to be a '${o}', but is missing : ${P(t)}`,"SC@03");return D("_shapeErrorMess EXIT",s),s}const Z=(e,t,n)=>{let r;D("_shapeArrayInArray ENTER",e,t,n);for(const o in e)r="",1===t.length?r+=q(e[o],t,n):r+=q(e[o],t[o],n);return D("_shapeArrayInArray EXIT",r),r};function q(e,t,n){D("_shapeContainer ENTER",e,t,n);let r="";const o=V(e),s=V(t);if(void 0===t)r="";else if(o!==s){r=B(`Parameter is meant to be '${s}' but is`+` of the wrong type of '${o}':${K(e)}`,"SC@36")}else"array"===s?("array"===V(t[0])&&(r=1===t.length?Z(e,t[0],n):Z(e,t,n)),r=ee(e,t,n)):"object"===s&&(r=ne(e,t,n));return D("_shapeContainer EXIT",r),r}const Q=(e,t,n)=>{D("_arrayOfOneType ENTER",e,t,n);let r="";const o=j(t);for(const t in e){const s=e[t],i=V(s);if(Y(o))r+=oe(s,o,n);else if(o!==i){r=B(`INDEX '${t}' is asserted to be a '${o}',`+` but is fallaciously a '${i}' : ${P(s)}`,"SC@45");break}}return D("_arrayOfOneType EXIT",r),r},ee=(e,t,n)=>{D("_shapeArrayTypes ENTER",e,t,n);let o="";if(1===t.length&&e.length>1)o=Q(e,t[0],n);else{const s=Array.from(t),i=s.length;for(const t in e){const i=V(e[t]),a=F(s,t);if(Y(a))o+=q(e[t],a,n);else{const e=j(F(s,t));if(e!==i)if(n===_&&void 0===e);else if(r&&"null"===i);else if(!r||"undefined"!==i){o=B(`INDEX '${t}' is assumed to be a '${e}',`+` but is mistakenly a '${i}'`,"SC@44");break}}delete s[t]}1!==i&&e.length<i&&(o=W(s,e))}return D("_shapeArrayTypes EXIT",o),o},te=(e,t,n)=>{D("_shapePropertyType ENTER",e,t,n);let r="";const o=j(e[t]);if(X(o)){const e=V(n);if(o!==e)if(void 0===n){r=B(`Key '${t}' was given to be a '${o}' but was instead 'undefined'`,"SC@41")}else if("null"===e){r=B(`Key '${t}' was determined to be a '${o}' but was instead 'null'`,"SC@42")}else{r=B(`Property '${t}' is indicated to be a '${o}',`+` but is inaccurately a '${e}' : ${P(n)}`,"SC@43")}}else{r=B(`The type '${o}' is not valid`,"SC@40")}return D("_shapePropertyType EXIT",r),r},ne=(e,t,n)=>{D("_shapeCollectionTypes ENTER",e,t,n);let r="";const o={...t},s=Object.entries(e);for(const[i,a]of s)if(Y(a)){const s=t[i];r+=q(e[i],s,n),delete o[i]}else if(Object.prototype.hasOwnProperty.call(o,i))r+=te(o,i,a),delete o[i];else if(n===d){r=B(`Extra key in checked_object - (${i}:'${a}')`,"SC@39")}return D("_shapeCollectionTypes EXIT",r+=G(o)),r};function re(e,t){let n;D("_shapeScalar ENTER",e,t);let r="";if(X(t)){const o=V(e);if(o===t)r="";else if("array"===o)n="[]",r=`The variable '[]', which is a 'array', is not a '${t}'`;else if("object"===o)n="{}",r=`The variable '{}', which is a 'object', is not a '${t}'`;else if("undefined"===o){r=B(`The variable '${n}', is not a '${t}'`,"SC@34")}else r=`The variable '${n=e}', which is a '${o}', is not a '${t}'`}else{r=B(`The type '${t}' is not valid`,"SC@33")}return D("_shapeScalar EXIT",r),r}function oe(e,t,n){let r;return D("_shapeVariable ENTER",e,t,n),D("_shapeVariable EXIT",r=Y(t)?q(e,t,n):re(e,t)),r}function se(e,t,n){D("_shapeCheck ENTER",e,t,n),N=R,r&&(N.add("null"),N.add("undefined"));const o=oe(e,t,n);return D("_shapeCheck EXIT",o),o}function ie(e,t){D("_emptyErrorMess ENTER",e,t);const n=Object.entries(e),[r,o]=n[0],s=B(`INDEX '${r}' is promised to be a '${o}', but is missing : ${K(t)}`,"SC@29");return D("_emptyErrorMess EXIT",s),s}function ae(e,t,n,r,o,s){let i;D("_emptyError ENTER",e,t,n,r,o,s);const a=K(r);if("EMPTY-ER"===e||"EM-ER"===e)if(U(t)){i=B(`INDEX '${n}' is erroneously empty : `,"SC@30")}else i="";else if("EMPTY-OK"===e||"EM-OK"===e)i=le(r[n],e,s);else if("string"===V(e)){i=B(`INDEX '${n}' is incorrect  type, '${e}', only`+` [EM-ER, EMPTY-ER, EMPTY-OK, EM-OK] allowed  : ${a}`,"SC@32")}else i=le(r[n],e,s);return D("_emptyError EXIT",i),i}const ce=(e,t,n)=>{D("_emptyArrayInArray ENTER",e,t,n);let r="";for(const o in e)if(1===t.length){let s=le(e[o],t,n);s&&(s+=` inside [${o}]`),r+=s}else r+=le(e[o],t[o],n);return D("_emptyArrayInArray EXIT",r),r},fe=(e,t,n)=>{D("_emptyArrayTypes ENTER",e,t,n);let r="";const o=e.length,s=t.length,i=P(JSON.stringify(e));if(0===o){r=B(`The parameter array ${i} is empty.`,"SC@19")}else if("EMPTY-EXTRAS"!==n&&s>1&&s!==o){r=B(`The parameter array ${i} does not have the same number of elements as ${P(JSON.stringify(t))}. `+` Lengths are different ${o} !== ${s}.`,"SC@20")}else{const o=Array.from(t),s=o.length;for(const t in e){const i=e[t],a=V(i),c=F(o,t);Y(c)?r+=le(e[t],c,n):1!==s&&delete o[t];const f=ae(c,i,t,e,a,n);if(f){r=f;break}}1!==s&&n!==$&&e.length!==s&&(r=ie(t,e))}return D("_emptyArrayTypes EXIT",r),r},ye=(e,t,n)=>{D("_emptyCollectionTypes ENTER",e,t,n);let r="";const o=M(e);if(o===C){const e=V(t);if(H(e)){if(U(t)){r=B(`'${n}' is a '${e}' which is reputed `+`to be '${o}' but has a value of ${K(t)}`,"SC@08")}}else{r=B(`Cannot be invalid '${n}' ${o}' is a ${t} :: ${e}`,"SC@09")}}else if(o!==O){r=B(`bad invalid key '${P(o)}', must be either EMPTY-OK/EM-OK or EMPTY-ER/EM-ER`,"SC@10")}return D("_emptyCollectionTypes EXIT",r),r},pe=(e,t,n)=>{D("_emptyCollectionTypes ENTER",e,t,n);let r="";const o={...t},s=Object.entries(e);for(const[i,a]of s){const s=M(o[i]);if(Y(a)){const s=M(t[i]);if(U(a)){r=B(`Key '${i}' was understood to be '${s}' but was instead '${K(a)}'`,"SC@26");break}r+=le(e[i],s,n),delete o[i]}else if(Object.prototype.hasOwnProperty.call(o,i)){const e=ye(s,a,i);if(e){r=e;break}delete o[i]}else if(n===b){r=B(`Extra key in checked_object - (${i}:'${a}')`,"SC@27");break}}return D("_emptyCollectionTypes EXIT",r+=G(o)),r};function le(e,t,n){let r;D("_emptyContainer ENTER",e,t,n);const o=V(t);return void 0===t?r="":"array"===o?("array"===V(t[0])&&(1===t.length&&(r=ce(e,t[0],n)),r=ce(e,t,n)),r=fe(e,t,n)):r="object"===o?pe(e,t,n):ue(e,t),D("_emptyContainer EXIT",r),r}function ue(e,t){D("_emptyScalar ENTER",e,t);let n="";const r=M(t),o=V(e);if(r===C){const t=V(e);if(H(t)){if(U(e)){n=B(`${r} states '${o}' must not `+`be empty for the value '${e}'`,"SC@24")}}else{n=B(`A '${o}' cannot be empty, so the state`+` of '${r}' is illegal for the value '${e}'`,"SC@25")}}else if(r!==O){n=B(`Must 'EMPTY-OK' or 'EMPTY-ER' not '${r}'`,"SC@11")}return D("_emptyScalar EXIT",n),n}function Ee(e,t,n){let r;return D("_emptyVariable ENTER",e,t,n),D("_emptyVariable EXIT",r=Y(t)?le(e,t,n):ue(e,t)),r}function he(e,t,n){let r;if(D("_emptyCheck ENTER",e,t,n),1!==t.length||t[0]!==O&&"EM-OK"!==t[0])r=Ee(e,t,n);else{r=B("Completely pointless as checking with ['EM-OK'] or ['EMPTY-OK'] matches everything","SC@12")}return D("_emptyCheck EXIT",r),r}function Te(e){D("_oneOfEmptyError ENTER",e);const t=B(`No empty entries in the list match the '${V(e)}'`,"SC@23");return D("_oneOfEmptyError EXIT",t),t}function me(e,t){D("_doOneOfEmpty ENTER",e,t);const[n,r]=t;let o="",s="";for(const t of r)if(""===(s=he(n,t,e))){D("*** MATCH OneOfEmpty",n),D("*** MATCH OneOfEmpty",t);break}return""!==s&&(o=Te(n)),D("_doOneOfEmpty EXIT",o),o}function Oe(e){D("_oneOfShapeError ENTER",e);const t=B(`No type shapes in the list match the '${V(e)}'`,"SC@22");return D("_oneOfShapeError EXIT",t),t}function Ce(e,t){D("_doOneOfShape ENTER",e,t);const[n,r]=t;let o="",s="";for(const t of r)if(""===(s=se(n,t,e))){D("*** MATCH OneOfShape",n),D("*** MATCH OneOfShape",t);break}return""!==s&&(o=Oe(n)),D("_doOneOfShape EXIT",o),o}function ge(e){D("_specParameters ENTER",e);for(const s of e)if("object"==typeof s)y=s;else if("UNDEF-OK"===s)r="UNDEF-OK";else if("DEBUG-CONSOLE-TRACE"===s)f="DEBUG-CONSOLE-TRACE";else if("THROW-EXCEPTIONS"===s)t="THROW-EXCEPTIONS";else if("LOG-ERRORS"===s)n="LOG-ERRORS";else if("CONSOLE-COUNT"===s)o="CONSOLE-COUNT";else if("NO-CHECKING"===s);else if("DEBUG-ERROR-TAGS"===s)c="DEBUG-ERROR-TAGS";else if(""!==s){let e=`Not THROW-EXCEPTIONS/LOG-ERRORS/UNDEF-OK/DEBUG-CONSOLE-TRACE/NO-CHECKING, unknown : ${K(s)}`;throw e=B(e,"SC@21")}S=!(!t&&!n)}function _e(e,t){D("_twoArrays ENTER",e,t);let n="";if(2!==e.length){n=B(`TypeCzech.${t}() has 2 arguments not ${e.length}`,"SC@14")}else{const[r,o]=e,s=V(r),i=V(o),a=JSON.stringify(s),c=JSON.stringify(o);if("array"===s&&"array"!==i){n=B(`TypeCzech.${t}() comparing actual [] parameter, with a`+` value of ['${r}'], against the expected shape of ${c}.`+` They should be the same type; both []s, or both ${c}s.`,"SC@58")}else if("array"===i&&"array"!==s){n=B(`TypeCzech.${t}() comparing actual '${s}' parameter, with a`+` value of '${r}', opposed to the expected shape of ${c}.`+` They should be the same type; both []s, or both '${s}'s.`,"SC@49")}else if("array"===i);else if("object"===i){if("object"!==s){n=B(`TypeCzech.${t}() called with '{}' against '!{}'.`+` Contrasting '${a}' with '${c}'.`,"SC@07")}}else if("string"!==i){n=B(`TypeCzech.${t}() called with 'a-variable' and 'not-a-variable type'.`+` Matching '${a}' with '${c}'.`+` Instead try TypeCzech.${t}(12, 'number')`,"SC@50")}}return D("_twoArrays EXIT",n),n}function de(e,t){D("_oneOfChecks ENTER",e,t);let n="";if(2!==e.length){n=B(`TypeCzech.${t}() needs 2 arguments, not ${e.length}`,"SC@51")}else{const r=e[1],o=JSON.stringify(r);if("array"!==V(r)){n=B(`TypeCzech.${t}() called with a second parameter`+` as a non-array shape of ${o}`,"SC@15")}}return D("_oneOfChecks EXIT",n),n}function $e(e){let t;return D("_getArguments ENTER",e),null==e||void 0===e.length||"string"==typeof e?t=e:1===e.length?[t]=e:t=[...e],D("_getArguments EXIT",t),t}return ge(e),l=J(y||!1),{_arrayOfOneType:Q,_aTypeOf:V,_canBeEmpty:H,_coloredConsole:z,_consoleError:B,_doOneOfEmpty:me,_doOneOfShape:Ce,_emptyArrayInArray:ce,_emptyArrayTypes:fe,_emptyCheck:he,_emptyCollectionTypes:pe,_emptyContainer:le,_emptyError:ae,_emptyErrorMess:ie,_emptyKeysChecked:ye,_emptyScalar:ue,_emptyVariable:Ee,_isArguments:L,_isCollection:Y,_isEmpty:U,_isValidType:X,_jsonStr:K,_missingKey:G,_oneOfChecks:de,_oneOfEmptyError:Te,_oneOfShapeError:Oe,_shapeArrayInArray:Z,_shapeArrayTypes:ee,_shapeCheck:se,_shapeCollectionTypes:ne,_shapeContainer:q,_shapeErrorMess:W,_shapeObjectInArray:(e,t,n)=>{D("_shapeObjectInArray ENTER",e,t,n);let r="";const o=V(t);for(const s in e){const i=e[s],a=V(i);if("object"===o){const e=q(i,t,n);if(e){r=B(`Index '${s}' - ${e}`,"SC@01");break}}else if(t!==a){r=B(`Index '${s}' is presumed to be a '${t}',`+` but is incorrectly a '${a}' : ${P(e)}`,"SC@02");break}}return D("_shapeObjectInArray EXIT",r),r},_shapePropertyType:te,_shapeScalar:re,_shapeVariable:oe,_shortToLongEmpty:M,_shortToLongType:j,_specParameters:ge,_toStr:P,_twoArrays:_e,_typeFromArray:F,TYPE_CZECH_EVENTS:w,REPLACE_NL_TAB_TAB:E,MATCH_NL_TAB_TAB:h,CONSOLE_LOG_NEWLINE:"|",ArgumentCheck:J,typeVerify:function(e,t){D("typeVerify ENTER",e,t);const n=$e(e);D("typeVerify START",n,t),_e([n,t],"typeVerify");const r=se(n,t,d),o=r?["typeVerify(arguments, expected_types)",r,t]:"";return D("typeVerify EXIT",o),o},typeExtras:function(e,t){D("typeExtras ENTER",e,t);const n=$e(e);_e([n,t],"typeExtras"),D("typeExtras START",n,t);const r=se(n,t,_),o=r?["typeExtras(arguments, expected_types)",r,t]:"";return D("typeExtras EXIT",o),o},typeOneOf:function(e,t){D("typeOneOf ENTER",e,t);const n=$e(e);D("typeOneOf START",n,t);let r=de([n,t],"typeOneOf");if(""===r){const e=Ce(d,[n,t]);r=e?["typeOneOf(arguments, expected_types)",e,t]:""}return D("typeOneOf ENTER",r),r},typeOneOfExtras:function(e,t){D("typeOneOfExtras ENTER",e,t);const n=$e(e);D("typeOneOfExtras START",n,t);let r=de([n,t],"typeOneOfExtras");if(""===r){const e=Ce(_,[n,t]);r=e?["typeOneOfExtras(arguments, expected_types)",e,t]:""}return D("typeOneOfExtras EXIT",r),r},setReturnType:function(e,t){const n=arguments.length;if(2!==n){let r=`TypeCzech.returnType('${e}', '${t}') needs 2 arguments, not ${n}`;throw r=B(r,"SC@18")}if("string"!=typeof e){let n=`TypeCzech.returnType('${e}', '${t}') first argument, the checked function's`+" name, must be a string";throw n=B(n,"SC@59")}if("string"!=typeof t||!R.has(t)){let n=`TypeCzech.returnType('${e}', '${t}') second argument, the checked function's`+` return type, must be one of [${[...R].join()}]`;throw n=B(n,"SC@60")}l.return_types_.set(e,t)},hasInterface:function(e,t){let n;if(D("hasInterface ENTER",e,t),L(e))n=B('TypeCzech.hasInterface() incorrectly called with a first parameter as "arguments". The first parameter should look something like {my-func:a_func, my-int:12} instead.',"SC@13");else if("object"===V(e)&&"object"===V(t)){_e([e,t],"hasInterface");const r=se(e,t,_);n=r?["hasInterface(arguments, expected_types)",r,t]:""}else n=B('TypeCzech.hasInterface() incorrectly called, both parameters should be objects. The first data parameter should look something like {my-func:a_func, my-int:12} instead. The second interface parameter should look something like {my-func:"function", my-int:"number"} instead.',"SC@17");return D("hasInterface EXIT",n),n},emptyVerify:function(e,t){D("emptyVerify ENTER",e,t);const n=$e(e);D("emptyVerify START",n,t),_e([n,t],"emptyVerify");const r=he(n,t,b),o=r?["emptyVerify(arguments, expected_emptys)",r,t]:"";return D("emptyVerify EXIT",e,t),o},emptyExtras:function(e,t){D("emptyExtras ENTER",e,t);const n=$e(e);D("emptyExtras START",n,t),_e([n,t],"emptyExtras");const r=he(n,t,$),o=r?["emptyExtras(arguments, expected_emptys)",r,t]:"";return D("emptyExtras ENTER",o),o},emptyOneOf:function(e,t){D("emptyOneOf ENTER",e,t);const n=$e(e);D("emptyOneOf START",n,t);let r=de([n,t],"emptyOneOf");if(""===r){const e=me(b,[n,t]);r=e?["emptyOneOf(arguments, expected_emptys)",e,t]:""}return D("emptyOneOf EXIT",r),r},emptyOneOfExtras:function(e,t){D("emptyOneOfExtras ENTER",e,t);const n=$e(e);D("emptyOneOfExtras START",n,t);let r=de([n,t],"emptyOneOfExtras");if(""===r){const e=me($,[n,t]);r=e?["emptyOneOfExtras(arguments, expected_emptys)",e,t]:""}return D("emptyOneOfExtras EXIT",r),r},precedeCheck:function(e,t){return l.checkArgs(e,t)},checkCount:function(){return l.checkCount_()},beginChecks:function(){return l.beginChecks_()},endChecks:function(){return l.endChecks_()},errorCount:function(){return l.errorCount_()},errorRatio:function(){return l.errorRatio_()}}}
</script>

<script>
  var NL=type_czech_copy.CONSOLE_LOG_NEWLINE;
  captureConsole("log-text");
  checkCodeRun();
  jsToDiv('js-code', "check-code");



  ;
</script>