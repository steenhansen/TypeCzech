<meta charset="utf-8" />


<link rel="stylesheet"
  href="https://fonts.googleapis.com/css?family=Inconsolata">

<div id='js-div' style="width:47%">
  <div id='js-code'>the javascript</div>
</div>

<div id="the-explanation" style="width:53%">
  <div class='an-explantion'>20 Overloaded Function Checks with Empty &amp; Valueless Parameters</div>
  <div id='explanation-text'>
    <br>

    If a function can take parameters with different empty shapes then conformity 
    can be checked with a call to emptyOneOf(). The below program will throw an 
    exception if <b>both</b> the first array and the second
    object parameter are empty. So AT_LEAST_ONE() checks to make sure that at least one
    of the array and object is not empty and has a value.  
<pre>
  type_czech = TypeCzech('THROW-EXCEPTIONS')            // runnable in console

  at_least_one = type_czech.precedeCheck(at_least_one, AT_LEAST_ONE) 
  
  function AT_LEAST_ONE() {                 // array[], object{}, string
    array_empty_err =  ['EM-ER', 'EM-OK', 'EM-ER']
    object_empty_err = ['EM-OK', 'EM-ER', 'EM-ER']
    array_or_object_empty = [array_empty_err, object_empty_err]
    return type_czech.emptyOneOf(arguments, array_or_object_empty) 
  }
    
  function at_least_one(an_array, an_object, what_str) {
    arr_len = an_array.length
    obj_len = Object.keys(an_object).length
    if (arr_len===0 && obj_len===0)  console.log(what_str, 'Impossible!')
    else if (arr_len>0 && obj_len>0) console.log(what_str, 'No Empties')
    else if (arr_len === 0)          console.log(what_str, 'Empty Array')
    else if (obj_len === 0)          console.log(what_str, 'Empty Object')
    else                             console.log(what_str, 'prog-error')
  }

  at_least_one([1], {a:1}, 'No Empties =')
  at_least_one([1], {},    'Empty Object =')
  at_least_one([],  {a:1}, 'Empty Array =')
  at_least_one([],  {},    'Exception halts the program')    // exception here
  </pre>
  </div>
</div>

<div id="console-log" style="width:53%">
  <div class='a-title'>Console Output</div>
  <div id='log-text'></div>
</div>





<script id="check-code">

function checkCodeRun(){

if (typeof TypeCzech === 'function')
  type_czech = TypeCzech('LOG-ERRORS') 
else
  type_czech = { precedeCheck : do_nothing => do_nothing }

//    PERSON(first, last, birth, job)
// OR PERSON({ name:'string', year:'number' })
function PERSON(){
  empty_first_last_birth_job = [ 'EM-ER', 'EM-OK', 'EM-ER', 'EM-OK' ]
  empty_name_year = { name:'EM-ER', year:'EM-ER' }
  empty_signatures = [ empty_first_last_birth_job, empty_name_year ]
  return type_czech.emptyOneOf(arguments, empty_signatures) 
}

PERSON = (typeof PERSON === 'undefined') ? undefined : PERSON
Person = type_czech.precedeCheck(Person, PERSON) 

//    Person(first, last, birth, job)
// OR Person({ name:'string', year:'number' })
function Person(){
  if (arguments.length===4) {
    const [first, last, birth, job] = arguments;
    const name = (last) ? `${first} ${last}` : first
    let year
    try { year = birth.getFullYear() } catch (e) { year = 0 }
    return [name, year, job]
  } else {
    const {name, year} = arguments[0]
    return [name, year, 'unemployed'] 
  }
}

function show(person, salutation) {
  const [name, year, job] = person
  return `${salutation} ${name}, ${year} ${job}`
}

elizabeth_1 = Person('Elizabeth I', '', new Date(1533, 9, 7), 'Queen')
console.log('out A : ', show(elizabeth_1, 'Ms'))

linesConsole(2)

queen_boudica = Person({name:'Boudica'})
console.log('out D : ', show(queen_boudica, 'Mrs'))

linesConsole(2)

space_baby = Person('2001: Space Odyssey Baby', 13, [], 43)
console.log('out E : ', show(space_baby, 'Alien'))

linesConsole(2)

athens_socrates = Person({name:'Socrates', year:-470})
console.log('out F : ', show(athens_socrates, 'Mr'))
}

</script>












<script s r c="../consolelog.js">
  const type_czech_copy={REPLACE_NL_TAB_TAB:new RegExp(/\\n\\t\\t/g),MATCH_NL_TAB_TAB:new RegExp(/\n\t\t/g),CONSOLE_LOG_NEWLINE:"|"},isNaN=e=>e!=e;let log_count=0,code_count=0;const NEW_LINE_REGEX=new RegExp(/\|/,"g"),NBSP_REGEX=new RegExp(/~/,"g"),UNDEFINED_AS_STR="un-defined";function startCurlyDates(e){return e.replace(/\n/g,"").replace(/([^}]),'/,"$1,'").split("},'").join("},\n"+type_czech_copy.CONSOLE_LOG_NEWLINE+"'").replace(/(\d\d\d\d-\d\d-\d\d)\w\d\d:\d\d:\d\d.\d\d\d\w/gi,"$1")}function printObj(e){return startCurlyDates(type_czech._jsonStr(e).replace(/},/g,"},\n")).replace(/^{/,"{|\n").replace(/}$/,"\n|}")}function captureConsole(e){const n=console.log,t=document.getElementById(e);function o(e,n){return void 0===n?UNDEFINED_AS_STR:n}function c(e){return function(e){if(void 0===e)return UNDEFINED_AS_STR;if("string"==typeof e)return e.replace(/"/g,"'");const n=JSON.stringify(e);return"object"!=typeof e?n:function(e){return e.replace(/{"/g,"{'").replace(/":/g,"':").replace(/","/g,"','").replace(/,"/g,",'").replace(/\["/g,"['").replace(/"]/g,"']").replace(/],"/g,"],'")}(n)}(JSON.stringify(e,o))}function i(e){let n;if("object"==typeof e)n=c(e);else if("string"==typeof e){const t=e.split("");let o="";for(const e of t)log_count+=1,single_section=`<span id='log-${log_count}' >${e}</span>`,o+=single_section;n=o.replace(NEW_LINE_REGEX,"<br>").replace(NBSP_REGEX,"&nbsp;")}else n=c(e);t.innerHTML+=n}function r(e){json_quotes=JSON.stringify(e[0],function(e,n){if(void 0===n)return"un-defined";if(Number.isNaN(n))return"-NaN-";if("function"==typeof n||n&&n.constructor===RegExp)return`${String(n).substring(0,30)} ...`;return n},2),'"'===json_quotes[0]?json_str=json_quotes.slice(1,-1):json_str=json_quotes;const n=json_str.replace(/\\"/g,'"'),o=type_czech_copy.CONSOLE_LOG_NEWLINE+"~~~~~~~~",c=n.replace(type_czech_copy.REPLACE_NL_TAB_TAB,o).replace(/(\d\d\d\d-\d\d-\d\d)\w\d\d:\d\d:\d\d.\d\d\d\w/gi,"$1").split("");let i="";for(const e of c)log_count+=1,single_section=`<span id='log-${log_count}'>${e}</span>`,i+=single_section;const r=i.replace(NEW_LINE_REGEX,"<br>").replace(NBSP_REGEX,"&nbsp;");t.innerHTML+=`${r} <br>`}console.log=function(...e){let o;!function(e){const t=Array.from(e);"string"==typeof t[0]&&(t[0]=t[0].replace(/<br>/gi,""),t[0]=t[0].replace(/\|/gi,""),t[0]=t[0].replace(/&nbsp;/gi," "),t[0]=t[0].replace(/~/gi," ")),"string"==typeof t[1]&&(t[1]=t[1].replace(/<br>/gi,""),t[1]=t[1].replace(/\|/gi,""),t[1]=t[1].replace(/&nbsp;/gi," "),t[1]=t[1].replace(/~/gi," ")),n(...t)}(e);const c=e[0],s=e[1];if("a-function"===(o="function"==typeof c?"a-function":"string"==typeof c&&c.match(/OUT/)?"string-string":"string"==typeof c&&c.match(type_czech_copy.MATCH_NL_TAB_TAB)?"multi-line":"string"==typeof c&&c.startsWith("%c")?"color-line":"string"==typeof c&&"object"==typeof s?"string-object":"object"==typeof e[0]?"one-object":"default-log"))a_function=e[0],func_str=a_function.toString(),func_nl=func_str.replace(/;/g,"|~~"),i(func_nl);else if("string-string"===o)i(e[0]),i(e[1]);else if("multi-line"===o)r(e);else if("color-line"===o)!function(e){if(!e[0].includes("ArgumentCheck-init")){const[n,o]=e[0].split(" "),c=parseInt(o,10);if(!isNaN(c)){const n=`<span style='${e[1]}'>${c}</span><br>`;t.innerHTML+=n}}}(e);else if("one-object"===o)r(e);else if("string-object"===o){i(e.shift()),r(e)}else if(i(e[0]),void 0!==e[1]){i(JSON.stringify(e[1]))}}}function linesConsole(e){const n=document.getElementById("log-text");for(let t=0;t!==e;t+=1)n.innerHTML+="<br>"}function jsToDiv(e,n){const t=document.scripts[n].firstChild.textContent.replace(/\n\s*linesConsole\([^)]*\)\n/g,"\n").replace(/\}\s+$/,"").replace(/^[^{]*\{/,"").split("");let o="";for(const e of t)single_section=`<span id='code-${code_count+=1}' >${e}</span>`,o+=single_section;document.getElementById(e).innerHTML=o}function fromToBackGround(e,n,t,o){if(n<e)throw new Error(`fromToBackGround() bad start/end : ${e} / ${n}`);for(i=e;i<=n;i+=1){const e=`${t}-${i}`,n=`back-${o}`,c=document.getElementById(e);c&&c.classList.add(n)}}function fromToBoldText(e,n,t,o){if(n<e)throw new Error(`fromToBoldText() bad start/end : ${e} / ${n}`);for(i=e;i<=n;i+=1){const e=`${t}-${i}`,n=`text-${o}`,c=document.getElementById(e);c&&c.classList.add(n)}}
  </script>

  <link r e l="stylesheet" href="../arg-check.css">
  <style>
  .a-title{font-family:arial;text-align:right;font-weight:700;margin-right:20px}.an-explantion{font-family:arial;text-align:center;font-weight:700;background-color:#ddd;margin-right:20px}#explanation-text{padding-left:8px;font-size:14px;font-family:arial}#console-log{float:right;font-family:Inconsolata,monospace;background-color:#eee}#js-div{float:left}#js-fiddles{float:left;background-color:#ddd}#js-code{white-space:pre;font-family:Inconsolata,monospace;tab-size:4;-moz-tab-size:4;margin-left:8px;margin-top:-32px;overflow-x:auto}#js-files{padding-left:8px}#log-text{padding-left:8px}#the-explanation{float:right;background-color:#ddd}ul{padding-left:16px;margin-top:0}li{padding-top:6px}.text-1{color:red;font-weight:700}.text-2{color:red;font-weight:700}.text-3{color:red;font-weight:700}.text-4{color:red;font-weight:bolder}.text-5{color:red;font-weight:bolder}.text-6{color:red;font-weight:bolder}.back-1{background-color:#ffe6e6}.back-2{background-color:#e6ffe6}.back-3{background-color:#e6e6ff}.back-4{background-color:#ffffa0}.back-5{background-color:#ffdcff}.back-6{background-color:#c8ffff}pre{background-color:#eee;margin-left:10px;margin-right:10px}
  </style>

  <script s r c="../TypeCzech.js">
  function TypeCzech(...e){let t=!1,n=!1,r=!1,o=!1;const s="ver 2.0",i="hasInterface(arguments, interface)",a="typeVerify(arguments, expected_types)",c="typeExtras(arguments, expected_types)",f="typeOneOf(arguments, expected_types)",y="typeOneOfExtras(arguments, expected_types)",l="emptyVerify(arguments, expected_emptys)",p="emptyExtras(arguments, expected_emptys)",u="emptyOneOf(arguments, expected_emptys)",E="emptyOneOfExtras(arguments, expected_emptys)",h="background: #ee0; color: #00F",T="background: #ee0; color: #F00",m="background: #cc0; color: #080";let C=!1,O=!1,g=!1;const _="TypeCzech";let b;const d="\n\t\t",$=new RegExp(/\\n\\t\\t/g),S=new RegExp(/\n\t\t/g),R=30,N="/(?:)/",A="EMPTY-OK",k="EMPTY-ER",I={"EM-OK":A,"EM-ER":k},x="TYPE-EXTRAS",w="TYPE-VERIFY",X="EMPTY-EXTRAS",j="EMPTY-VERIFY";let P=!1;const v=new Set(["symbol","date","function","number","string","boolean","array","object","regexp"]);let M=new Set(["symbol","date","function","number","string","boolean","array","object","regexp"]);const L={y:"symbol",d:"date",f:"function",n:"number",s:"string",b:"boolean",r:"regexp"},V="-un-defined-",K="-NaN-",Y="TypeCzech-init",D={backBlink:e=>{document.body.style.background=e,setTimeout(()=>{document.body.style.background="white"},100)},onStart:()=>D.backBlink("green"),onCheck:()=>D.backBlink("blue"),onError:()=>D.backBlink("red")};function z(e){return!!v.has(e)||!!L[e]}function U(e){return L[e]?L[e]:e}function B(e){return I[e]?I[e]:e}function G(e){if(void 0===e)return V;if("string"==typeof e){return e.replace(/"/g,"'")}const t=JSON.stringify(e);return"object"!=typeof e?t:function(e){return e.replace(/{"/g,"{'").replace(/":/g,"':").replace(/","/g,"','").replace(/,"/g,",'").replace(/\["/g,"['").replace(/"]/g,"']").replace(/],"/g,"],'")}(t)}function F(e,t){if(void 0===t)return V;if(Number.isNaN(t))return K;if("function"==typeof t||t&&t.constructor===RegExp){return`${String(t).substring(0,R)} ...`}return t}function H(e){return G(JSON.stringify(e,F))}function J(e){return null===e?"null":e instanceof Date?"date":e instanceof RegExp?"regexp":Array.isArray(e)?"array":typeof e}function W(e){const t=!Array.isArray(e),n="object"==typeof e,r="number"==typeof e.length;if(t&&n&&r){if("0,1,length,callee"===Object.getOwnPropertyNames(e).join())return!0}return!1}function Z(e){const t=J(e);return"array"===t||"object"===t}function q(e,t){const n=JSON.stringify(e),r=n.substring(1,n.length-1);console.log(`%c ${r}`,t)}function Q(...e){O&&q(e,h)}function ee(e,t){if(C&&t){const n=`${t} - ${e}`;return O&&q(n,T),n}return e}function te(e){if(Object.keys(e).length>0){const[t,n]=Object.entries(e)[0];let r=`The key '${t}', which has a type of '${n}', is missing in the checked object`;return r=ee(r,"SC@46")}return""}function ne(e){if(e instanceof Date)return"Invalid Date"==e;if(e instanceof RegExp){return e.toString()===N}if(Number.isNaN(e))return!0;if(null==e)return!0;const t=0===e.length,n="object"==typeof e&&0===Object.keys(e).length;return t||n}const re=e=>"array"===e||("object"===e||("string"===e||("regexp"===e||("date"===e||"number"===e))));function oe(e,t){let n;return Q("_typeFromArray ENTER",e,t),1===e.length?[n]=e:n=e[t],Q("_typeFromArray EXIT",n),n}function se(e){if(arguments.length>1){let e=`TypeCzech.checkArgs() needs 0 or 1 arguments, not ${arguments.length}`;throw e=ee(e,"SC@53")}let l=()=>"",p=()=>"",u=0,E=0,C=!1,O=!1;function g(e,r,s,l){u+=1,o&&q([u],h);const T=l.apply(r,s);if(T){E+=1,p();let r=`${_} - ${e}() - `;if(r="string"==typeof T?T:function(e,t,n){const[r,o,s]=n,l=H(e).slice(1,-1),p=H(s);let u,E,h=t+o;return h+=d+r,r===i?(u="  ACTUAL INTERFACE",E="EXPECTED INTERFACE"):r===a||r===c||r===f||r===y?(u=" ACTUAL VALUE",E="EXPECTED TYPE"):(u=" ACTUAL VALUE",E="EXPECTED EMPTY"),h+=`${d}${u} ${l}`,h+=`${d}${E} ${p}`}(s,r,T),t)throw r;n&&console.log(r)}}function b(e,t){if(function(e,t){let n;if(void 0===e){let e="ArgumentCheck The 'checked_function' must be in the exact same scope as checked_function="+`ArgumentCheck(checked_function) and ${t.name}() to be available for overriding`;throw e=ee(e,"SC@05")}if(void 0!==e.is_ArgumentCheck_Proxy){if("object"==typeof t){const e=e=>`${e}()`,r=(e,t)=>`${e}, ${t}`;n=`{ ${Object.keys(t).map(e).reduce(r)} }`}else n=`${t.name}()`;let r=`ArgumentCheck ${e.name}() is already proxied with ${n}`;throw r=ee(r,"SC@04")}}(e,t),"function"!=typeof e||"function"!=typeof t&&"object"!=typeof t){let n=`ArgumentCheck both '${H(e)}' and '${H(t)}' must be functions`;throw n=ee(n,"SC@38")}if(e===t){let n=`ArgumentCheck you cannot use ${e.name}() to test`+`${t.name}(), they must be different functions`;throw n=ee(n,"SC@28")}try{e.is_ArgumentCheck_Proxy=Symbol("is_ArgumentCheck_Proxy")}catch(e){throw ee(G(e.message),"SC@47")}return function(e,t){let n;n="object"==typeof t?t[e.name]:t;if("function"!=typeof e){let t=`TypeCzech.checkArgs target_proxy is not a function ${G(e)}`;throw t=ee(t,"SC@06")}return void 0===n?()=>"":n}(e,t)}function $(e,t,n){if("object"==typeof n)for(const r in n)if(r!==e){const e=n[r];t[r]=S(t[r],e)}return t}const S=P?function(e,r){if(Q("realCheckArgs ENTER",e,r),function(e){if(2!==e){let t=`TypeCzech.checkArgs() needs 2 arguments, not ${e}`;throw t=ee(t,"SC@52")}}(arguments.length),void 0===r)return e;const o=b(e,r),s="object"==typeof r,i=e.name;return new Proxy(e,{apply(e,a,c){l(),C&&g(i,a,c,o);const f=e.apply(a,c);return s?$(i,f,r):(function(e,r){if(O.has(r)){const o=O.get(r);if(Te(e,o,w)){const s=H(e),i=H(o),a=`The function '${r}' is improperly returning a`+` result type of ${s}, ${d}`+`In lieu of the expected type of ${i}.`;if(t)throw a;n&&console.log(a)}}}(f,i),f)},construct(e,t){l(),C&&g(i,void 0,t,o);const n=new e(...t);return $(i,n,r)}})}:e=>e;return P&&(O=new Map,e&&"object"!==J(e)&&q(["ArgumentCheck - arg_check_events is not an object with onStart(), onCheck(), onError() ",e],T),q([Y,s,t?"THROW-EXCEPTIONS":"",n?"LOG-ERRORS":"",r?"UNDEF-OK":"",o?"CONSOLE-COUNT":"",e],m),void 0!==e.onStart&&e.onStart(),void 0!==e.onCheck&&(l=e.onCheck),void 0!==e.onError&&(p=e.onError),C=!0),{checkArgs:S,return_types_:O,checkCount_:function(){return u},beginChecks_:function(){C=!0,u=0,E=0},endChecks_:function(){C=!1},errorCount_:function(){return E},errorRatio_:function(){return`${E}/${u}`}}}function ie(e,t){Q("_shapeErrorMess ENTER",e,t);const n=Object.entries(e),[r,o]=n[0],s=ee(`Index '${r}' is supposed to be a '${o}', but is missing : ${G(t)}`,"SC@03");return Q("_shapeErrorMess EXIT",s),s}const ae=(e,t,n)=>{let r;Q("_shapeArrayInArray ENTER",e,t,n);for(const o in e)r="",1===t.length?r+=ce(e[o],t,n):r+=ce(e[o],t[o],n);return Q("_shapeArrayInArray EXIT",r),r};function ce(e,t,n){Q("_shapeContainer ENTER",e,t,n);let r="";const o=J(e),s=J(t);if(void 0===t)r="";else if(o!==s){r=ee(`Parameter is meant to be '${s}' but is`+` of the wrong type of '${o}':${H(e)}`,"SC@36")}else"array"===s?("array"===J(t[0])&&(r=1===t.length?ae(e,t[0],n):ae(e,t,n)),r=le(e,t,n)):"object"===s&&(r=ue(e,t,n));return Q("_shapeContainer EXIT",r),r}const fe=(e,t,n)=>{Q("_arrayOfOneType ENTER",e,t,n);let o="";const s=U(t);for(const t in e){const i=e[t],a=J(i);if(Z(s))o+=he(i,s,n);else if(s!==a)if(r&&"null"===a);else if(!r||"undefined"!==a){o=ee(`INDEX '${t}' is asserted to be a '${s}',`+` but is fallaciously a '${a}' : ${G(i)}`,"SC@45");break}}return Q("_arrayOfOneType EXIT",o),o},ye=(e,t,n)=>{if(void 0!==e&&!z(e)){let t=`The type '${e}' is not valid. Try one of : ${H(L)}`;throw t=ee(t,"SC@60")}const r=ee(`INDEX '${t}' is assumed to be a '${e}',`+` but is mistakenly a '${n}'`,"SC@44");return Q("_wrongType EXIT",r),r},le=(e,t,n)=>{Q("_shapeArrayTypes ENTER",e,t,n);let o="";if(1===t.length&&e.length>1)o=fe(e,t[0],n);else{const s=Array.from(t),i=s.length;for(const t in e){const i=J(e[t]),a=oe(s,t);if(Z(a))o+=ce(e[t],a,n);else{const e=U(oe(s,t));if(e!==i)if(n===x&&void 0===e);else if(r&&"null"===i);else if(!r||"undefined"!==i){o=ye(e,t,i);break}}delete s[t]}1!==i&&e.length<i&&(o=ie(s,e))}return Q("_shapeArrayTypes EXIT",o),o},pe=(e,t,n)=>{Q("_shapePropertyType ENTER",e,t,n);let o="";const s=U(e[t]);if(z(s)){const e=J(n);if(s!==e)if(r&&"null"===e);else if(r&&"undefined"===e);else if(void 0===n){o=ee(`Key '${t}' was given to be a '${s}' but was instead 'undefined'`,"SC@41")}else if("null"===e){o=ee(`Key '${t}' was determined to be a '${s}' but was instead 'null'`,"SC@42")}else{o=ee(`Property '${t}' is indicated to be a '${s}',`+` but is inaccurately a '${e}' : ${G(n)}`,"SC@43")}}else{o=ee(`The type '${s}' is not valid`,"SC@40")}return Q("_shapePropertyType EXIT",o),o},ue=(e,t,n)=>{Q("_shapeCollectionTypes ENTER",e,t,n);let r="";const o={...t},s=Object.entries(e);for(const[i,a]of s)if(Z(a)){const s=t[i];r+=ce(e[i],s,n),delete o[i]}else if(Object.prototype.hasOwnProperty.call(o,i))r+=pe(o,i,a),delete o[i];else if(n===w){r=ee(`Extra key in checked object - (${i}:'${a}')`,"SC@39")}return Q("_shapeCollectionTypes EXIT",r+=te(o)),r};function Ee(e,t){let n;Q("_shapeScalar ENTER",e,t);let r="";if(z(t)){const o=J(e);if(o===t)r="";else if("array"===o)n="[]",r=`The variable '[]', which is a 'array', is not a '${t}'`;else if("object"===o)n="{}",r=`The variable '{}', which is a 'object', is not a '${t}'`;else if("undefined"===o){r=ee(`The variable '${n}', is not a '${t}'`,"SC@34")}else r=`The variable '${n=e}', which is a '${o}', is not a '${t}'`}else{r=ee(`The type '${t}' is not valid`,"SC@33")}return Q("_shapeScalar EXIT",r),r}function he(e,t,n){let r;return Q("_shapeVariable ENTER",e,t,n),Q("_shapeVariable EXIT",r=Z(t)?ce(e,t,n):Ee(e,t)),r}function Te(e,t,n){Q("_shapeCheck ENTER",e,t,n),r&&(M.add("null"),M.add("undefined"));const o=he(e,t,n);return Q("_shapeCheck EXIT",o),o}function me(e,t){Q("_emptyErrorMess ENTER",e,t);const n=Object.entries(e),[r,o]=n[0],s=ee(`INDEX '${r}' is promised to be a '${o}', but is missing : ${H(t)}`,"SC@29");return Q("_emptyErrorMess EXIT",s),s}function Ce(e,t,n,r,o,s){let i;Q("_emptyError ENTER",e,t,n,r,o,s);const a=H(r);if("EMPTY-ER"===e||"EM-ER"===e)if(ne(t)){i=ee(`INDEX '${n}' is erroneously empty : `,"SC@30")}else i="";else if("EMPTY-OK"===e||"EM-OK"===e)i=de(r[n],e,s);else if("string"===J(e)){i=ee(`INDEX '${n}' is incorrect  type, '${e}', only`+` [EM-ER, EMPTY-ER, EMPTY-OK, EM-OK] allowed  : ${a}`,"SC@32")}else i=de(r[n],e,s);return Q("_emptyError EXIT",i),i}const Oe=(e,t,n)=>{Q("_emptyArrayInArray ENTER",e,t,n);let r="";for(const o in e)if(1===t.length){let s=de(e[o],t,n);s&&(s+=` inside [${o}]`),r+=s}else r+=de(e[o],t[o],n);return Q("_emptyArrayInArray EXIT",r),r},ge=(e,t,n)=>{Q("_emptyArrayTypes ENTER",e,t,n);let r="";const o=e.length,s=t.length,i=G(JSON.stringify(e));if(0===o){r=ee(`The parameter array ${i} is empty.`,"SC@19")}else if("EMPTY-EXTRAS"!==n&&s>1&&s!==o){r=ee(`The parameter array ${i} does not have the same number of elements as ${G(JSON.stringify(t))}. `+` Lengths are different ${o} !== ${s}.`,"SC@20")}else{const o=Array.from(t),s=o.length;for(const t in e){const i=e[t],a=J(i),c=oe(o,t);Z(c)?r+=de(e[t],c,n):1!==s&&delete o[t];const f=Ce(c,i,t,e,a,n);if(f){r=f;break}}1!==s&&n!==X&&e.length!==s&&(r=me(t,e))}return Q("_emptyArrayTypes EXIT",r),r},_e=(e,t,n)=>{Q("_emptyCollectionTypes ENTER",e,t,n);let r="";const o=B(e);if(o===k){const e=J(t);if(re(e)){if(ne(t)){r=ee(`'${n}' is a '${e}' which is reputed `+`to be '${o}' but has a value of ${H(t)}. `,"SC@08")}}else{r=ee(`Cannot be invalid '${n}' ${o}' is a ${t} :: ${e}`,"SC@09")}}else if(o!==A){r=ee(`bad invalid key '${G(o)}', must be either EMPTY-OK/EM-OK or EMPTY-ER/EM-ER`,"SC@10")}return Q("_emptyCollectionTypes EXIT",r),r},be=(e,t,n)=>{Q("_emptyCollectionTypes ENTER",e,t,n);let r="";const o={...t},s=Object.entries(e);for(const[i,a]of s){const s=B(o[i]);if(Z(a)){const s=B(t[i]);if(ne(a)){r=ee(`Key '${i}' was understood to be '${s}' but was rather '${H(a)}'`,"SC@26");break}r+=de(e[i],s,n),delete o[i]}else if(Object.prototype.hasOwnProperty.call(o,i)){const e=_e(s,a,i);if(e){r=e;break}delete o[i]}else if(n===j){r=ee(`Extra key in checked object - (${i}:'${a}')`,"SC@27");break}}return Q("_emptyCollectionTypes EXIT",r+=te(o)),r};function de(e,t,n){let r;Q("_emptyContainer ENTER",e,t,n);const o=J(t);return void 0===t?r="":"array"===o?("array"===J(t[0])&&(1===t.length&&(r=Oe(e,t[0],n)),r=Oe(e,t,n)),r=ge(e,t,n)):r="object"===o?be(e,t,n):$e(e,t),Q("_emptyContainer EXIT",r),r}function $e(e,t){Q("_emptyScalar ENTER",e,t);let n="";const r=B(t),o=J(e);if(r===k){const t=J(e);if(re(t)){if(ne(e)){n=ee(`${r} states '${o}' must not `+`be empty for the value '${e}'`,"SC@24")}}else{n=ee(`A '${o}' cannot be empty, so the state`+` of '${r}' is illegal for the value '${e}'`,"SC@25")}}else if(r!==A){n=ee(`Must 'EMPTY-OK' or 'EMPTY-ER' not '${r}'`,"SC@11")}return Q("_emptyScalar EXIT",n),n}function Se(e,t,n){let r;return Q("_emptyVariable ENTER",e,t,n),Q("_emptyVariable EXIT",r=Z(t)?de(e,t,n):$e(e,t)),r}function Re(e,t,n){let r;if(Q("_emptyCheck ENTER",e,t,n),1!==t.length||t[0]!==A&&"EM-OK"!==t[0])r=Se(e,t,n);else{r=ee("Completely pointless as checking with ['EM-OK'] or ['EMPTY-OK'] matches everything","SC@12")}return Q("_emptyCheck EXIT",r),r}function Ne(e){Q("_oneOfEmptyError ENTER",e);const t=ee(`No empty entries in the list match the '${J(e)}'`,"SC@23");return Q("_oneOfEmptyError EXIT",t),t}function Ae(e,t){Q("_doOneOfEmpty ENTER",e,t);const[n,r]=t;let o="",s="";for(const t of r)if(""===(s=Re(n,t,e))){Q("*** MATCH OneOfEmpty",n),Q("*** MATCH OneOfEmpty",t);break}return""!==s&&(o=Ne(n)),Q("_doOneOfEmpty EXIT",o),o}function ke(e){Q("_oneOfShapeError ENTER",e);const t=ee(`No type shapes in the list match the '${J(e)}'`,"SC@22");return Q("_oneOfShapeError EXIT",t),t}function Ie(e,t){Q("_doOneOfShape ENTER",e,t);const[n,r]=t;let o="",s="";for(const t of r)if(""===(s=Te(n,t,e))){Q("*** MATCH OneOfShape",n),Q("*** MATCH OneOfShape",t);break}return""!==s&&(o=ke(n)),Q("_doOneOfShape EXIT",o),o}function xe(e){Q("_specParameters ENTER",e);for(const s of e)if("object"==typeof s)g=s;else if("UNDEF-OK"===s)r="UNDEF-OK";else if("DEBUG-CONSOLE-TRACE"===s)O="DEBUG-CONSOLE-TRACE";else if("THROW-EXCEPTIONS"===s)t="THROW-EXCEPTIONS";else if("LOG-ERRORS"===s)n="LOG-ERRORS";else if("CONSOLE-COUNT"===s)o="CONSOLE-COUNT";else if("NO-CHECKING"===s);else if("DEBUG-ERROR-TAGS"===s)C="DEBUG-ERROR-TAGS";else if(""!==s){let e=`Not THROW-EXCEPTIONS/LOG-ERRORS/UNDEF-OK/DEBUG-CONSOLE-TRACE/NO-CHECKING, unknown : ${H(s)}`;throw e=ee(e,"SC@21")}P=!(!t&&!n)}function we(e,t){Q("_twoArrays ENTER",e,t);let n="";if(2!==e.length){n=ee(`TypeCzech.${t}() has 2 arguments not ${e.length}`,"SC@14")}else{const[r,o]=e,s=J(r),i=J(o),a=JSON.stringify(s),c=JSON.stringify(o);if("array"===s&&"array"!==i){n=ee(`TypeCzech.${t}() comparing actual [] parameter, with a`+` value of ['${r}'], against the expected shape of ${c}.`+` They should be the same type; both []s, or both ${c}s.`,"SC@58")}else if("array"===i&&"array"!==s){n=ee(`TypeCzech.${t}() comparing actual '${s}' parameter, with a`+` value of '${r}', opposed to the expected shape of ${c}.`+` They should be the same type; both []s, or both '${s}'s.`,"SC@49")}else if("array"===i);else if("object"===i){if("object"!==s){n=ee(`TypeCzech.${t}() called with '{}' against '!{}'.`+` Contrasting '${a}' with '${c}'.`,"SC@07")}}else if("string"!==i){n=ee(`TypeCzech.${t}() called with 'a-variable' and 'not-a-variable type'.`+` Matching '${a}' with '${c}'.`+` Preferably try TypeCzech.${t}(12, 'number')`,"SC@50")}}return Q("_twoArrays EXIT",n),n}function Xe(e,t){Q("_oneOfChecks ENTER",e,t);let n="";if(2!==e.length){n=ee(`TypeCzech.${t}() needs 2 arguments, not ${e.length}`,"SC@51")}else{const r=e[1],o=JSON.stringify(r);if("array"!==J(r)){n=ee(`TypeCzech.${t}() called with a second parameter`+` as a non-array shape of ${o}`,"SC@15")}}return Q("_oneOfChecks EXIT",n),n}function je(e){let t;return Q("_getArguments ENTER",e),null==e||void 0===e.length||"string"==typeof e?t=e:1===e.length?[t]=e:t=[...e],Q("_getArguments EXIT",t),t}return xe(e),b=se(g||!1),{_arrayOfOneType:fe,_aTypeOf:J,_canBeEmpty:re,_coloredConsole:q,_consoleError:ee,_doOneOfEmpty:Ae,_doOneOfShape:Ie,_emptyArrayInArray:Oe,_emptyArrayTypes:ge,_emptyCheck:Re,_emptyCollectionTypes:be,_emptyContainer:de,_emptyError:Ce,_emptyErrorMess:me,_emptyKeysChecked:_e,_emptyScalar:$e,_emptyVariable:Se,_isArguments:W,_isCollection:Z,_isEmpty:ne,_isValidType:z,_jsonStr:H,_missingKey:te,_oneOfChecks:Xe,_oneOfEmptyError:Ne,_oneOfShapeError:ke,_shapeArrayInArray:ae,_shapeArrayTypes:le,_shapeCheck:Te,_shapeCollectionTypes:ue,_shapeContainer:ce,_shapeErrorMess:ie,_shapeObjectInArray:(e,t,n)=>{Q("_shapeObjectInArray ENTER",e,t,n);let r="";const o=J(t);for(const s in e){const i=e[s],a=J(i);if("object"===o){const e=ce(i,t,n);if(e){r=ee(`Index '${s}' - ${e}`,"SC@01");break}}else if(t!==a){r=ee(`Index '${s}' is presumed to be a '${t}',`+` but is incorrectly a '${a}' : ${G(e)}`,"SC@02");break}}return Q("_shapeObjectInArray EXIT",r),r},_shapePropertyType:pe,_shapeScalar:Ee,_shapeVariable:he,_shortToLongEmpty:B,_shortToLongType:U,_specParameters:xe,_toStr:G,_twoArrays:we,_typeFromArray:oe,_wrongType:ye,TYPE_CZECH_EVENTS:D,REPLACE_NL_TAB_TAB:$,MATCH_NL_TAB_TAB:S,CONSOLE_LOG_NEWLINE:"|",ArgumentCheck:se,typeVerify:function(e,t){Q("typeVerify ENTER",e,t);const n=je(e);Q("typeVerify START",n,t);let r=we([n,t],"typeVerify");if(""===r){const e=Te(n,t,w);r=e?[a,e,t]:""}return Q("typeVerify EXIT",r),r},typeExtras:function(e,t){Q("typeExtras ENTER",e,t);const n=je(e);Q("typeExtras START",n,t);let r=we([n,t],"typeExtras");if(""===r){const e=Te(n,t,x);r=e?[c,e,t]:""}return Q("typeExtras EXIT",r),r},typeOneOf:function(e,t){Q("typeOneOf ENTER",e,t);const n=je(e);Q("typeOneOf START",n,t);let r=Xe([n,t],"typeOneOf");if(""===r){const e=Ie(w,[n,t]);r=e?[f,e,t]:""}return Q("typeOneOf ENTER",r),r},typeOneOfExtras:function(e,t){Q("typeOneOfExtras ENTER",e,t);const n=je(e);Q("typeOneOfExtras START",n,t);let r=Xe([n,t],"typeOneOfExtras");if(""===r){const e=Ie(x,[n,t]);r=e?[y,e,t]:""}return Q("typeOneOfExtras EXIT",r),r},setReturnType:function(e,t){const n=arguments.length;if(2!==n){let r=`TypeCzech.returnType('${e}', '${t}') needs 2 arguments, not ${n}`;throw r=ee(r,"SC@18")}if("string"!=typeof e){let n=`TypeCzech.returnType('${e}', '${t}') first argument, the checked function's`+" name, must be a string";throw n=ee(n,"SC@59")}b.return_types_.set(e,t)},hasInterface:function(e,t){let n;if(Q("hasInterface ENTER",e,t),W(e))n=ee('TypeCzech.hasInterface() incorrectly called with a first parameter as "arguments". The first parameter should look something like {my-func:a_func, my-int:12} oppositely.',"SC@13");else if("object"===J(e)&&"object"===J(t)){if(""===(n=we([e,t],"hasInterface"))){const r=Te(e,t,x);n=r?[i,r,t]:""}}else n=ee('TypeCzech.hasInterface() incorrectly called, both parameters should be objects. The first data parameter should look something like {my-func:a_func, my-int:12} alternately. The second interface parameter should look something like {my-func:"function", my-int:"number"} alternately.',"SC@17");return Q("hasInterface EXIT",n),n},emptyVerify:function(e,t){Q("emptyVerify ENTER",e,t);const n=je(e);Q("emptyVerify START",n,t);let r=we([n,t],"emptyVerify");if(""===r){const e=Re(n,t,j);r=e?[l,e,t]:""}return Q("emptyVerify EXIT",r),r},emptyExtras:function(e,t){Q("emptyExtras ENTER",e,t);const n=je(e);Q("emptyExtras START",n,t);let r=we([n,t],"emptyExtras");if(""===r){const e=Re(n,t,X);r=e?[p,e,t]:""}return Q("emptyExtras ENTER",r),r},emptyOneOf:function(e,t){Q("emptyOneOf ENTER",e,t);const n=je(e);Q("emptyOneOf START",n,t);let r=Xe([n,t],"emptyOneOf");if(""===r){const e=Ae(j,[n,t]);r=e?[u,e,t]:""}return Q("emptyOneOf EXIT",r),r},emptyOneOfExtras:function(e,t){Q("emptyOneOfExtras ENTER",e,t);const n=je(e);Q("emptyOneOfExtras START",n,t);let r=Xe([n,t],"emptyOneOfExtras");if(""===r){const e=Ae(X,[n,t]);r=e?[E,e,t]:""}return Q("emptyOneOfExtras EXIT",r),r},precedeCheck:function(e,t){return b.checkArgs(e,t)},checkCount:function(){return b.checkCount_()},beginChecks:function(){return b.beginChecks_()},endChecks:function(){return b.endChecks_()},errorCount:function(){return b.errorCount_()},errorRatio:function(){return b.errorRatio_()}}}
  </script>



<script>
  var NL=type_czech_copy.CONSOLE_LOG_NEWLINE;
  captureConsole("log-text");
  checkCodeRun();
  jsToDiv('js-code', "check-code");


 ///////////////

  
 fromToBackGround(1318, 1333, 'code', 1)  // {name:'Boudica'}


  
fromToBackGround(1409, 1446, 'code', 2)  // Person('2001: Space Odyssey Baby', 13, new Date(2042,1,1), 43)


 fromToBoldText(1441, 1442, 'code', 2)    // []

///////////////////



   fromToBackGround(177, 194, 'log', 1)  //   ACTUAL VALUE {'name':'Boudica'}

   fromToBoldText(270, 283, 'log', 1)    // 'year':'number'}]




  fromToBackGround(468, 502, 'log', 2)  // ACTUAL VALUE '2001: Space Odyssey Baby',13,'2042-02-01',43





 fromToBoldText(498, 499, 'log', 2)    //   [],43

fromToBoldText(545, 551, 'log', 2)    // 'XPECTED TYPE [['EM-ER','EM-OK','EM-ER'


</script>